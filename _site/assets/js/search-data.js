var store = [{
        "title": "Welcome to Bots in Pieces",
        "excerpt":"It’s launch day, so let’s get started! Thank you for visiting my new site. For those not familiar with my work,I have been contributing open source software to the communityfor the past several years and have also documented some of my work on another site blog. What You Can Expect To Find On This Site   Small targeted posts          I can be wordy at times, so the goal here is to keep me in check, and keep the posts short and sweet. Wish me luck ;-)      A suggested read time is shown for all posts so you can budget your time.        Project Presentations          A Step-by-step (or better yet, component by component) approach to project implementation.      Each step presented will include:                  Design decision discussions.          Design explanations          Links to fully functional and reuseable code.                      Tips and tricks.  Opinion Pieces          Everything from setting up a development environment, to hardware and software reviews.      So to keep with my pledge of keeping things short and sweet, let’s get to work. Sneak  preview: the first project that will be discussed is a Bluetoothcontrolled, Raspberry Pi based roving vehicle. The Bot The Banyan Bot Blue The Control App (Based On Work By Martyn Currey)  The Android Control App On A Kindle Fire Tablet ","categories": [],
        "tags": [],
        "url": "http://localhost:4000/bots-in-pieces/2019/06/08/welcome-to-bots-in-pieces.html"
      },{
        "title": "Banyan Bot Blue: Part 1",
        "excerpt":"Over the next several postings, we will be constructing the first generationBanyan Bot Robot. This version will beRaspberry Pi based and remotely controlled using an Android Bluetooth device. Yes I know, that has beendone a million times before, but the robot is not my main motivation for this project. My main motivation is to demonstrate how to create reusable software components. That is softwarecomponents that will act as off-the-shelf entities to be reused, without modification in future projects. So for example, if I wish to swap out the Raspberry Pi for an ESP-8266, I should be able to reuse most of the components created for this project. Just plug themin and they should be good to go! To accomplish the goal of reusablity, we will be using a softwareframework called Python Banyan. Python Banyan allows one to create small, targetedcomponents that communicate with each other over a LAN based software backplane.And as the name implies, this framework is implemented in Python.   JavaScript, Ruby, and Java Programmers:   Banyan is also available for these languages as well. Any component written in any of the supported languages is compatible withcomponents written in any of the other languages. So if Python is not your language of choice,anything presented here in Python is still available to you for reuse. Advantages Of Using A Software Framework Software frameworks allow you to focus on the problem at hand by taking care of the low-level details. Banyan, no matter the language implementation, handles all of thenetworking and inter-component communication details. In fact, when you first instantiatea Banyan component, it will automatically plug itself into the software backplane without you havingto remember to manage that. A High-Level View Of Python Banyan Python Banyan implements and takes advantage of a software pattern known as the publish/subscribe model. Banyan is built on top of the ZMQ Messaging Library A Banyan component may at its option, publish, or transmit data over the LAN. Also, any component can elect to receivedata by requesting to receive it. The data, known as a payload, is transmitted in the form of Python dictionary.When a payload is published, a topic is associated with the payloadand published as well.To receive data, a component subscribes to one or more topics. The payloads, and only therequested payloads, are placed on the subscriber’s receive queue to process.  All of the queuing and routing is handled by the framework, again freeing you fromlow-level details. The framework guarantees that messages will be received in the order that they are sent and handles all encoding for transmission across the network. We will get into more detail about Python Banyan in a future post. Python In The House I have selected Python as the language of choice for this project (and probably those in the future as well). So why Python? Well, one reason is that a recent articlepredicts that Python will overtake both Java and C in 4 years. When selecting a language for use, I like to consider the following:   The amount of quality code that can be written in a day.  The quality of its native library.  The availability of a large choice of additional open source libraries and frameworks.  The quality and ease of access to help.  The language’s portability across multiple computing platforms without the need for recompilation.  And most important to me,  “Do I have a smile on my face at the end of the day or a frustrationfrown?”For me, Python checks all the boxes. Hardware Components Used In This Project   An Android cell phone or tablet (Kindle Fire Tablets work nicely here).  Raspberry Pi 3B+  Adafruit Crickit Hat For The Raspberry Pi (motor control and sensor input).  A 2 motor, 5 Volt, robot chassis. Here are some links to examples of this type of chassis:          From Amazon      From Pololu      From Adafruit      I will be reusing a chassis from a previous project      Software Components Below is a Banyan component diagram for this project. With the exception of the cell phone app, allsoftware components will be resident on the Raspberry Pi.  The Components:   External (Non-Banyan) Components:          A Bluetooth Android app to control the rover’s motion and that has the ability to receive and report status information from the rover.        Banyan Components:          Bluetooth Gateway                  Acts as a Bluetooth RFCOMM server for the Android device.          Converts data received from the Android device and publishes that data as a Banyan message.          Converts Banyan report messages into a form that the Android app can process and transmits those messages over the Bluetooth link.                    Robotics Gateway                  Converts message data originated from the Android device and published by the Bluetooth Gateway into Banyan motion control messages.          Converts and relays Banyan messages from the Raspberry Pi to the Android device.                    Cricket Gateway                  Receives Banyan motion messages from the Robotics Gateway and translates these into Cricket API commands.          Receives sensor updates from the Cricket and translates and publishes this data as Banyan messages.                    Each component will be discussed in detail in future posts. Next Time: Coding the Android App ","categories": ["Banyan-Bot-Blue","python-banyan"],
        "tags": [],
        "url": "http://localhost:4000/bots-in-pieces/banyan-bot-blue/python-banyan/2019/06/10/banyan-bot-blue-part-1.html"
      },{
        "title": "Banyan Bot Blue Part 2",
        "excerpt":"Preparing The Raspberry Pi For Bluetooth Communication In this edition of Bots In Pieces, we will:   Configure the Raspberry Pi for Bluetooth RFCOMM communications.  Explain how to pair an Android device with the Raspberry Pi.  Install the pybluez Python package.  Install a Bluetooth Server test tool.  Don’t have an Android device? Not to worry!   In a future post, a tkinter component will be presented that can beused to replace the Android app and Bluetooth server. This will allow youto drive the robot directly on the Raspberry Pi desktop. Configuring The Raspberry Pi, Bluetooth, and RFCOMM Communications. As you will see, the process is pretty simple to do. Just follow the simple steps below. Enabling The Raspberry Pi For Pairing. Step 1: Update Raspbian - open a terminal and type: sudo apt-get updatesudo apt-get upgradeStep 2: In the terminal type the following: sudo rfkill unblock allThis will unblock the Bluetooth device on your RPi if it is in a blocked state. Step 3: Invoke the bluetoothctl program: sudo bluetoothctlThen enter the following three commands: power ondiscoverable onpairable on You should see something like the following in your terminal: pi@BanyanBot:~ $ sudo bluetoothctl[NEW] Controller B8:27:EB:25:1A:EA BanyanBot [default][bluetooth]# power onChanging power on succeeded[bluetooth]# discoverable onChanging discoverable on succeeded[bluetooth]# pairable onChanging pairable on succeeded[bluetooth]# When first starting bluetoothctl the first line displays the RPi’s Bluetooth MAC addressand hostname. For each of the 3 commands, the tool will indicate success or failure. Pairing The Raspberry Pi To An Android Device Consult your Android Device Manual for exact instructions. I am using a Kindle Fire Tablet as an example.       Power On your Android Device.         Go to the device’s settings for Bluetooth and turn Bluetooth On.         Select “Pair A Bluetooth Device.         Perform a scan for Bluetooth devices and select the hostname of your Raspberry Pi when the scan completes.         You should see that the Android device is now paired with your Raspberry Pi         If you go back to the Raspberry Pi, and look at the output on bluetoothctl, you shouldsee something that looks like the following:     [bluetooth]# power onChanging power on succeeded[bluetooth]# discoverable onChanging discoverable on succeeded[CHG] Controller B8:27:EB:25:1A:EA Discoverable: yes[bluetooth]# pairable onChanging pairable on succeeded[NEW] Device 00:BB:3A:06:A0:24 Alan's Kindle HDX[CHG] Device 00:BB:3A:06:A0:24 Modalias: bluetooth:v001Dp1200d1436[CHG] Device 00:BB:3A:06:A0:24 UUIDs: 0000110a-0000-1000-8000-00805f9b34fb[CHG] Device 00:BB:3A:06:A0:24 UUIDs: 0000110c-0000-1000-8000-00805f9b34fb[CHG] Device 00:BB:3A:06:A0:24 UUIDs: 00001200-0000-1000-8000-00805f9b34fb[CHG] Device 00:BB:3A:06:A0:24 UUIDs: 00001800-0000-1000-8000-00805f9b34fb[CHG] Device 00:BB:3A:06:A0:24 UUIDs: 00001801-0000-1000-8000-00805f9b34fb[CHG] Device 00:BB:3A:06:A0:24 ServicesResolved: yes[CHG] Device 00:BB:3A:06:A0:24 Paired: yes[CHG] Device 00:BB:3A:06:A0:24 ServicesResolved: no[CHG] Device 00:BB:3A:06:A0:24 Connected: no      It shows that pairing was successful. Notice that we are not connected yet. Enabling The Raspberry Pi For RFCOMM Serial Communication.   Close the bluetoothctl tool by either entering exit or pressing Control-D.  We are about to make some changes to the /etc/systemd/system/dbus-org.bluez.service file.Before doing so, let’s make a back-up copy of the file in case anything goes wrong. In the terminal you have opentype: sudo cp /etc/systemd/system/dbus-org.bluez.service /etc/systemd/system/dbus-org.bluez.service.BACKUPThis is a very long line so make sure that you copy it all.   Now we need to make changes to the file. We will modify one line and add a new line.Open up the file with your favorite editor using sudo privileges:sudo nano /etc/systemd/system/dbus-org.bluez.service  Here is what the file may look like:[Unit]Description=Bluetooth serviceDocumentation=man:bluetoothd(8)ConditionPathIsDirectory=/sys/class/bluetooth[Service]Type=dbusBusName=org.bluezExecStart=/usr/lib/bluetooth/bluetoothdNotifyAccess=main#WatchdogSec=10#Restart=on-failureCapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICELimitNPROC=1ProtectHome=trueProtectSystem=full[Install]WantedBy=bluetooth.targetAlias=dbus-org.bluez.service  In the third line in the [Service] section, we need to add -C to the end of the line. Change:ExecStart=/usr/lib/bluetooth/bluetoothdto: ExecStart=/usr/lib/bluetooth/bluetoothd -C  And right below that line, we need to add the following new line:    ExecStartPost=/usr/bin/sdptool add SP      The [Service] section should now look like: [Service]Type=dbusBusName=org.bluezExecStart=/usr/lib/bluetooth/bluetoothd -CExecStartPost=/usr/bin/sdptool add SPNotifyAccess=main#WatchdogSec=10#Restart=on-failureCapabilityBoundingSet=CAP_NET_ADMIN CAP_NET_BIND_SERVICELimitNPROC=1ProtectHome=trueProtectSystem=full  Save the file and exit the editor.  Reboot the Raspberry Pi.Installing A Bluetooth Test Server In the next post, we will be connecting an Android app to our Raspberry Pi usingBluetooth. This app requires a Bluetooth server to be running on the RPi, and solet’s install one now. First, Let’s Update pip To The Latest And Greatest. The server requires the pybluez Python package tobe installed on the Raspberry Pi. Before doing so, let’s take the opportunity to updatepip on the RPi to the latest version. If you are running Raspbian Buster you can skip this step. Open a terminal window on your Raspberry Pi and type the following command: sudo pip3 install -U pipInstall The pybluez Library First install the required libraries for pybluez.In your console type: sudo apt-get install libbluetooth-devNext, in your console type: sudo pip3 install pybluezCopy The Test Server To Your Raspberry Pi The source code for the server may be found at this link.Create a banyan-bot-blue directory on your Raspberry Pi, then create a test_fixtures directory. Copy the testserver to that directory. banyan-bot-blue└── test_fixtures    └── bluetooth_apk_validation_server.pyIf you look at the server code you will see that the server initially prints out amessage that it is waiting for a client to connect. import bluetoothprint('Waiting for client to connect...')server_sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)port = 1server_sock.bind((\"\", port))server_sock.listen(1)After a successful connection, it sendsa short text message to the client and then sits in a loop receiving data from theclient and printing the data to the console. client_sock, address = server_sock.accept()print(\"Accepted connection from \", address)data = 'Hello Banyan Bot'data = data.encode()client_sock.send(data)while True:    data = (client_sock.recv(1024)).decode()print(\"received [%s]\" % data)To run the server it must be invoked with sudo: sudo python3 bluetooth_apk_validation_server.pyYou should see the Waiting for client to connect… message.You can then kill the server. That concludes this post. Next time - we build an Android app to control the robot and connect it to the server. ","categories": ["Banyan-Bot-Blue","Bluetooth","Bluetooth-test-server"],
        "tags": ["pip","pybluez"],
        "url": "http://localhost:4000/bots-in-pieces/banyan-bot-blue/bluetooth/bluetooth-test-server/2019/06/15/banyan-bot-blue-part-2.html"
      },{
        "title": "Banyan Bot Blue Part 3",
        "excerpt":"An Android App For Robot Control In this edition of Bots In Pieces, we will:   Discuss the Android app that will control our robot’s motion.  Install the app on an Android device.  Connect the app to the Bluetooth test server discussed in the previous post.  Explain the  modifications made to the Android app to better meet our needs.Origins Of The Android App In full disclosure, for the most part, the Android control app we will use was developed byMartyn Currey. I did however, make some simple modifications to meet the needs of this project. Martyn developed the app using App Inventor, and his articledoes an excellent job at explaining the visual aspects as well as the coding aspects of his project.It is well worth the read. If you are unfamiliar with App Inventor, it is a Web-based IDE that allows you to easily createAndroid apps. It provides a drag-and-drop GUI design editor and a block language for codingthe program logic. It is fairly easy to use and there are many tutorials availablethat explain how to use it. What did the original app look like on an Android device? Here is a screenshot from the original article:  Changes To Martyn’s Work The changes are minor. In the original design, when any of the on-screen buttons are pressed,a command consisting of an uppercase letter is sent across the Bluetooth link. When the button is released,a command consisting of a lower case letter is sent across the Bluetooth link. I have retained the concept of upper and lower case commands, however, I changed the command values for the red and green buttons and changed the name of the button displayed. For the red button, I changed the command from ‘R’ and ‘r’ to ‘S’ and ‘s’. I also changed the display text from One to Spin Right Similarly for the green button, I changed the command from ‘G’ and ‘g’ to ‘W’ and ‘w’. I also changed the display text from Two to Spin Left For the blue button, I only removed the display text, since we will not be using this button for this project. Here is a summary of button actions and the data generated for each action.             Button      Pressed      Released                  Up      ‘U’      ‘u’              Down      ‘D’      ‘d’                  Left      ‘L’      ‘l’              Right      ‘R’      ‘r’                  Spin Left      ‘S’      ’s’              Spin Right      ‘W’      ‘w’      In addition to the button changes, I’ve also added a screen widget to receiveand display data sent from the Raspberry Pi. This feature was added to demonstrate that two-way communication is possible between client and server over Bluetooth. If you look at the modified screen below, you will see that a Report: label was added to thescreen. When data is received, it will be displayed next to this label. And finally, I changed the title of the app to Banyan Bot Blue.  The details of these changes are explained in a section at the bottom of this post. Before looking at the details of the changes, let’s first load and use the app. Running The App On Your Android Device Getting The Code When working with App Inventor, you can save your project to a file that will have a .aia extension.This file may be loaded into App Inventor if you wish to view or modify the project. App Inventor also allows you to create a .apk file, which is an Android executable allowing you to runthe app on your device. Both the project file, b_bot_blue.aia, and the app, b_bot_blue.apk, areavailable for download on Github. Loading The Modified APK Into Your Android Device To run b_bot_blue.apk on your Android device, you will need to sideload it. Here are general instructionson how to do so, but you might want to search for instructions for your specific device. Testing The App With The BlueTooth Test Server Step 1 Follow the instructions  from this previous post, to pair your Raspberry Pi to your Android device and to enable your Raspberry Pi  for serial communications over Bluetooth. Step 2 Launch the Bluetooth Test Server on your Raspberry Pi with the following command: sudo python3 bluetooth_apk_validation_server.py Step 3 Launch the Android app on your Android device.  Step 4 Connect the app by pressing the blue Connect button on the upper rightcorner of the Android app. This will bring you to a Connection Screen. It willsay NOT CONNECTED  Step 5 Press the blue NOT CONNECTED button on the android device. This willbring up a screen to allow you to select a device to connect to. Select the Raspberry Pithat was paired earlier from the list of devices.  Step 6 The connection screen should now show that the device is connected. Press the grayBACK button.  Step 7 You are now ready to use the app. Notice that the dot in the upperleft-hand corner turned from red to blue, indicating that you are connected.Notice that the Report is no longer blank, but says Hello Banyan Bot. Thisstring was sent from the Bluetooth server on the Raspberry Pi.  Step 8 Press the buttons on the app, and look at the console on the Raspberry Pi. Youshould the button commands printed to the console.  The following sections describe the details of the changes that I made to the original app. Understanding The App Inventor Changes Made To The Original App Loading The Project Into App Inventor First, download b_bot_blue.aia.Next, in App Inventor, select Projects from the menu and click on Import project(.aia) from my computer…  A file-chooser dialog will appear. Select the .aia file to load into the editor. Designer Changes The App Inventor Editor has 2 modes, Designer and Blocks. You select the modeby clicking on either of the buttons located on the top right of the editor.  Here are the design changes I made:   Changed the title label text from Bluetooth Joypad to Banyan Bot Blue.  Changed the button text for the Red and Green buttons.  Removed the button text for the Blue button.  Added a Report: label next to the title label.  Added an empty label that will display incoming data.  Added the non-visible timer sensor widget.Changing The Properties of A GUI Widget If you click on any widget that you’ve dragged into the Designer editor, a Properties menu for that widgetwill appear on the right side of the editor.   Using the properties editor, you can change the look and feel of a widget. In the screenshot above, the red button was selected and the textfor the button was changed to Spin Right. Adding New Widgets To add a widget, select a widget from the User Interface palette.  Drag and drop the widget onto the Viewer sectionof the editor depicting your design. You will see a new component added to the components window of the editor.  For this project, the report component is a label that will contain data receivedfrom the RPi. The Label15 component is the label that contains the text Report:. In general, when making changes to the original project I did not rename the widgets. Adding The Clock Sensor Widget To receive data from the Raspberry Pi, we need to add the non-visible clock widget to our design.To do this, select Sensors from the Palette menu on the left side of the editor, and then drag the clockto the center of the editor. You should see the clock added to the list of non-visible components just belowyour screen design.  Modified App Inventor Code Blocks To change the behavior of a widget, we need to interact with the code blocks.To do this, select Blocks in the upper right of the App Inventor Editor. Let’s look at the blocks for the red, green and blue buttons.Below you will see the original blocks and the modified blocksfor these buttons. The command values were changed to meet our needs. Original Blocks For The Buttons Original Commands Modified Blocks for The Buttons Modified Commands New Blocks To Receive and Display Data To receive data, we need to add some code. The blocks below show how to receivedata from the Raspberry Pi and print the data to the Report section of the app.   Blocks Added To Receive Incoming Data Coming Up In The Next Post Now that we have an Android app loaded and ready to go, in the next post, we will startbuilding Banyan components to translate the Android commands into motor actions. ","categories": ["Banyan-Bot-Blue","Android","Bluetooth"],
        "tags": [],
        "url": "http://localhost:4000/bots-in-pieces/banyan-bot-blue/android/bluetooth/2019/06/16/banyan-bot-blue-part-3.html"
      },{
        "title": "Banyan Bot Blue Part 4",
        "excerpt":"Understanding The Banyan Framework In this edition of Bots In Pieces, we will:   Discuss the basics of the Python Banyan Framework.  Discuss the Banyan design philosophy.  Install the Python Banyan Framework On The Raspberry Pi  Discuss the Banyan components used for the Banyan Blue Bot project.  Discuss using Tuning Parameters to allow for maximal component reuse.Banyan 101 - The Why, What,  And How This posting will provide a quick introduction to the Python Banyan Framework.After reading this posting, if you would like tolearn more about the Banyan Framework, please check out the User’s Guide.   If you have any questions or comments about this or any other posting, please feel free to leave acomment. There is a comment section at the bottom of each posting page. Checkout out our Comment Policy. The Why The purpose of a software framework is to help you manage the low level, mundane details of your application. This not onlyallows you to concentrate on the problem at hand, but helps to simplify your coding and testing burden. Python Banyan does just that. The What A Banyan application consists of one or more modules known as Banyan components. Each componentwhen instantiated automatically, connects itself to the local network by using the Banyan message distribution mechanism, known as the Banyan Backplane. When a component wishes to shareinformation with other components it publishes a Banyan protocol message to the network. A Banyan protocol message is simply a populated Python dictionary. The keys of the message are typically text strings,and the associated value for each key is typically a text string or numeric value. Python Banyan also supportsNumpy data values, making it simple to share Numpy data within a Banyan application. All protocol messages are created by you, the application developer. An example of a Banyan protocol message might be: payload = {'command': 'move_robot', 'direction': 'forward', 'speed': 60}When a component publishes a protocol message, it associates a topic with the message and both are published to the network as a single entity. To publish a message, the component uses one of Python Banyan’s built-in methods, namedpublish_payload. The publish_payload method accepts two parameters, the dictionary comprising the message payload and a topic string. To publish the message described above with a topic of control_robot, themethod call would look like: payload = {'command': 'move_robot', 'direction': 'forward', 'speed': 60}self.publish_payload(payload, 'control_robot')To receive a protocol message, a component subscribes to one or more topics of interest. It will only receive messages that it has subscribed to - theframework filters out the rest. When a component receives a message, the framework calls its incoming_message_processing method. This method is built into the framework - you just need to overwrite its defaultcontents. Here is the source code for this method:     def incoming_message_processing(self, topic, payload):        \"\"\"        Override this method with a custom Banyan message processor for subscribed messages.            :param topic: Message Topic string.            :param payload: Message Data.        \"\"\"        if self.external_message_processor:            self.external_message_processor(topic, payload)        else:            print('this method should be overwritten in the child class', topic, payload)Both the received payload, in the form of a Python dictionary, and its topic string are passed into this method by the framework.Unchanged, this method will print the topic and payload to the console. Typically all of the processing of the message is handled within this method, but you may createan alternative method within the component to handle message processing. You do so by setting self.external_message_processor when you instantiate the component. This Is A Good Time To Install Python Banyan If you are using the Stretch version of Raspbian and have not already updated your pip3 loader,this would be a good time to do so. Open a terminal window and type: sudo pip3 install -U pipIf you are using the Buster version of Raspbian, you do not have to update pip3, unlessyou get an update message from pypi. For this project, we also need to install the boltons library To install type: sudo pip3 install boltonsNext to install python-banyan, type: sudo pip3 install python-banyanOn Stretch, this should take about 10-15 minutes. On Buster it should take only about2 to 3 minutes. Once installed, you will be able to import Python Banyan into your project. In addition to installing the library files, the python-banyan distribution installs 3 command line executables: the  backplane the monitor, and the banyan launcher (bls). The Backplane Before starting any Banyan component, the Banyan Backplane must be running.To start the backplane, just type the following in your terminal: backplaneYou should see something like this in your terminal: backplane******************************************Backplane IP address: 192.168.2.188Subscriber Port = 43125Publisher  Port = 43124Loop Time = 0.001 seconds******************************************When any Banyan Component is started, it displays a heading similar to the one above.The name of the component is displayed followed by the IP address of the Backplane.The Subscriber and Publisher ports are IP ports used by the framework for sending and receiving Banyan protocol messages. The default port values may be tuned by using command line options when invoking the backplane. The Loop Time is the amount of timethe Banyan event loop waits to check for the possibility of the arrival of the nextprotocol message.This also is a tunable value. The Monitor The monitor is a debugging tool that will display all published messages and their associated topics to the console. We will talk more about this later. If you would like to try a simple Banyan application, please look atthis example. Since we installed python-banyanfor Python 3, please use python3 when running the example. The Banyan Launcher This utilitylaunches the backplane and all the components of yourBanyan application from a single command line. Some Additional What The Banyan Framework at its lowest level uses TCP/IP to manage message communication.Items like retransmission and buffering are handled automatically for you as part of the framework. Because TCP/IP is being used, messages are guaranteed to be received in the order that they weresent. The Banyan Framework automatically and transparently handles both connection to the network and data encoding/decoding fordata transmission and receipt. It is important to note that Banyan messages are not computer language specific. Versions of theBanyan Framework are available forJavaScript, Java, and Ruby. Each of these languages has an equivalent data structure to the Python dictionary, allowing a Banyan component written in one language to communicate with a component written in another language without any modification to the message or components. The How The Python Banyan Framework is implemented as a Python class. To create a Banyancomponent, you create a new class that inherits from the Banyan base class. In thatway, your component automatically has all the low-level functionalitybuilt-in. Typically, the inherited class only has to implement or overwrite 2 methods. The first is the __init__method. You may add any initialization code that is specific to your component to this method.The second is the incoming_message_processing method discussed above. Of course, you can add any additional methods that your component may require to do its job. Banyan Based Applications One way of thinking about a Banyan application is to compare it to a factory assembly line. As a Banyan messagemakes its way from its origin to its destination, it is intercepted by intermediaryBanyan components. Each component provides a value-added service to the data. Thatvalue added may be as simple as performing a calculation using the incoming data and then publishing the results of its calculation,or perhaps, it may transform the data to another form that the next component in line will process. Banyan Application Design Philosophy When designing a Banyan Component, it is best to limit the scope of processing for the component.Not only does this make the component simpler to code, but it also  makes it easier to test.This allows you to implement a quality component quickly and with the best chance of reuse in thefuture. Other than the requirement that you derive your Banyan component from theBanyan base class, there are really no other restrictions when using the framework.The Banyan Framework is extremely flexible and does not limit your design in any way.For example, although not often needed, you can incorporate multi-threading into a Banyan component or even asyncio.Banyan also integrates well with other event loop driven frameworks, such as tkinter. The Banyan Bot Blue Components The Banyan Bot application is comprised of 3 Banyan components:   The Bluetooth Gateway  The Robot Controller  The Hardware Control Gateway. Specifically for this application, the Hardware Control Gateway communicates with and controlsan Adafruit Crickit controller.If we decide at a later time to swap out the Crickit controller for some other controller, theBluetooth Gateway and Robot Controller will remain unchanged. This allows for maximum flexibilityin design with minimal recoding.The Banyan BlueTooth Gateway This Banyan BlueTooth Gateway is a Banyan Protocol Gateway. The function of a Banyan Protocol Gateway is to convert data to and from some protocol other than the Banyan messaging protocol.  For this project, we need to convert Bluetooth data into Banyan protocol messages. Another example  of a Banyan Protocol Gateway is the   MQTT Gateway.  In the case of the Bluetooth Gateway, its function is to act as a Bluetooth server, and when Bluetooth data is received over theRFCOMM link, it converts that data to a Banyan protocol message. The Bluetooth Gatewayalso has the capability of subscribing to Banyan protocol messages, extracting the data from the message and transmittingthat data over the RFCOMM link. The Robot Controller The Robot Controller subscribes to receive generic robot control commands. Ittranslates and publishes those commands as protocol messages that the hardware control component canuse to control the robot. It also subscribes to receive any reportdata that the hardware control component publishes, such as bumpersensor data. It uses that data to autonomously affect robot motion. It also publishes the reportdata so that the user may see the report on their display.    Note that none of the components are actually directly aware of any of the other components. A component has no idea which other component published a message it subscribes to and has no ideawhat other components make use of the messages it publishes. The Hardware Controller (Crickit Controller) The Cricket Controller is an instance of a Banyan Hardware Gateway.  Banyan Hardware Gateways conform to the Banyan OneGPIO Protocol MessagingSpecification. Simply put, OneGPIO protocol messages describe hardware interactions usinga high-level abstraction that is not specific to any one hardware platform. The Hardware Gateway translates the generic OneGPIO messages into messages that arehardware specific. It also accepts report messages generated by the hardware andtranslates these reports into a Banyan protocol message and then publishes them. Using OneGPIO, we can easily swap out one hardware control platform for another, justby changing the Banyan Hardware Gateway without having to modify any of the other componentswithin the application. Tuning Banyan Components As stated previously, one of the main reasons to use Banyan is becauseit offers the opportunity for maximum code reuse. This means writing thecode once and being able to use it in different application settings. Depending upon the application, you may need to change some defaultvalues for the componentor you may need to change the component’s interface. We accomplish this by using thePython argparse library. The use of argparse is totally optional but all of the Banyan Bot Bluecomponents take advantage of argparse. Argparse allows us to pass in command line options to affect the behaviorand configuration of a component. One command line option that argparse automatically generates for us is the-h option. The -h option prints a list of all the command line parametersavailable for the component. In most cases, the default values can be used and so no command line optionsare necessary, but if we need to tune those values, we can do so easilywithout having to edit the code. Below is thehelp screen for the robot_control component. pi@BanyanBot:~/banyan-bot-blue/banyan_assets $ python3 robot_control.py -husage: robot_control.py [-h] [-b BACK_PLANE_IP_ADDRESS]                        [-d PUBLISH_TO_HARDWARE_TOPIC]                        [-l ADDITIONAL_SUBSCRIBER_LIST [ADDITIONAL_SUBSCRIBER_LIST ...]]                        [-n PROCESS_NAME] [-p PUBLISHER_PORT]                        [-r PUBLISH_TO_UI_TOPIC] [-s SUBSCRIBER_PORT]                        [-t LOOP_TIME] [-u SUBSCRIBE_FROM_UI_TOPIC]                        [-v SUBSCRIBE_FROM_HARDWARE_TOPIC]optional arguments:  -h, --help            show this help message and exit  -b BACK_PLANE_IP_ADDRESS                        None or IP address used by Back Plane  -d PUBLISH_TO_HARDWARE_TOPIC                        Publishing topic for hardware commands  -l ADDITIONAL_SUBSCRIBER_LIST [ADDITIONAL_SUBSCRIBER_LIST ...]                        Banyan topics space delimited: topic1 topic2 topic3  -n PROCESS_NAME       Set process name in banner  -p PUBLISHER_PORT     Publisher IP port  -r PUBLISH_TO_UI_TOPIC                        Publishing topic for report messages  -s SUBSCRIBER_PORT    Subscriber IP port  -t LOOP_TIME          Event Loop Timer in seconds  -u SUBSCRIBE_FROM_UI_TOPIC                        Topic From User Interface  -v SUBSCRIBE_FROM_HARDWARE_TOPIC                        Topic From HardwareAs you can see this component has many options that we can use to tune the component.We can manually set the backplane IP address, or change default publishing or subscriptiontopics or change several other parameters within the component. This gives the component optimal flexibility and allows for maximum reuse. More on these parameters when we address using each component in future posts. Preview Of The Next Post In the next post, we will demonstrate testing and using the Banyan Bot Blue components.We will be using the monitor to help us test and we will use the Banyan Launcherto start our components. See you next time. ","categories": ["banyan-framework"],
        "tags": ["banyan-gateways","backplane","monitor"],
        "url": "http://localhost:4000/bots-in-pieces/banyan-framework/2019/06/26/banyan-background-4.html"
      },{
        "title": "Banyan Bot Blue Part 5",
        "excerpt":" The Bluetooth Gateway A Peek Under The Hood   In this edition of Bots In Pieces, we will:   Discuss the Banyan Bluetooth Gateway (BTG) component:          Its purpose.      A peek at the code:                  What’s inside.          Adding threading.Thread to a Banyan component.          Transforming a Banyan component into a command-line executable.                    What Is The Bluetooth Gateway? The BTG is a Banyan Protocol Gateway that supports seamless bidirectionaldata transfer between a Bluetooth device and the Banyan network. It re-formats Bluetooth data received from a Bluetoothdevice into Banyan protocol messages, while simultaneously receiving Banyan messages and reformatting that data to a format that can be sent over the RFCOMM link to the Bluetooth device. By default, the BTG acts asa Bluetooth RFCOMM server.  The Bluetooth Gateway was designed to be as general-purpose as possible in order to supporta variety of application scenarios without the need to recode the component. It accomplishes this goal by offering a set of command-line options available to the user at launch time to affect the BTG’s behavior. The Bluetooth Gateway Command-Line Options Here is a list of all the command-line options that the BTG supports:           -a SERVER_BT_ADDRESS  Bluetooth MAC Address of Bluetooth Gateway          -b BACK_PLANE_IP_ADDRESS                                None or IP address used by Back Plane          -g GATEWAY_TYPE       Type of Gateway: server or client          -j JSON_DATA          Bluetooth packets json encoded True or False          -l PUBLISH_TOPIC      Banyan publisher topic          -m SUBSCRIBER_LIST [SUBSCRIBER_LIST ...]                                Banyan topics space delimited: topic1 topic2 topic3          -n PROCESS_NAME       Set process name in banner          -p PUBLISHER_PORT     Publisher IP port          -s SUBSCRIBER_PORT    Subscriber IP port          -t LOOP_TIME          Event Loop Timer in seconds          -u UUID               Bluetooth UUID      SERVER_BT_ADDRESS - if you configure the gateway as an RFCOMM client, you will need to specify its Bluetooth MAC address. By default, the BTG is configuredas a Bluetooth server, and for server mode, the address does not need to be specified.The default value for this option is None.         BACK_PLANE_IP_ADDRESS - this is a common option for all Banyan components. Banyan allows you to distribute components across multiple computers.This option allows you to explicitly specify the IP address of the computer that ishosting the backplane. The default is None, which automatically sets the backplane IP address to the IP address of the local computer.         GATEWAY_TYPE - select either server or client. Default is server.         JSON_DATA - The BTG can be configured to treat data over the Bluetooth RFCOMMlinkas either JSON or string data. Setting this option to True enablesJSON encoding, and False enables string encoding. The default option value is False for string encoding.         PUBLISH_TOPIC - the topic string used when the BTG publishes Banyan messagescontaining Bluetooth data. The default is from_bt_gateway.         SUBSCRIBER_LIST - a space-delimited list of BTG subscription topics. Default is a single topic ofto_bt_gateway.         PROCESS_NAME - The name of the component that will be displayed in the console headerwhen the gateway is launched. Default isBanyanBluetoothServer. If you’ve selected a GATEWAY_TYPE of client, the process_name will be BanyanBluetoothClient.         PUBLISHER_PORT -  This option specifies the IP port used when publishing Banyan messages. The default is 43124. You may choose a different port number if thisport is already in use,  or if you have configured the Banyan network as a multi-backplane network.         SUBSCRIBER_PORT - This option specifies the IP port used for receiving Banyan messages. The default is 43125. You may choose a different port number if thisport is already in use,  or if you have configured the Banyan network as a multi-backplane network.         LOOP_TIME - the time period that the Banyan receive loop remains idle before checking to see if the next received messageis available for processing. This option allows you to tune the component for performance and CPU utilization. The default value is 0.01 seconds.         UUID - A Unique Bluetooth service identifier. Default is: e35d6386-1802-414f-b2b9-375c92fa23e0.   The Code In this section, we will be examining selected portions of the code.You can view the code in its entiretyhere.   If you have any questions about the code, please leave a comment at the bottom of this page. As explained in a previous posting, in general, to create a Banyan component the programmer:   Creates a class that inherits from the Python Banyan base class.  Overwrites the __init__ method.  Calls the parent class __init__ method.  Overwrites the incoming_message_processing method to handle Banyan messages.Discussing The Code For code discussions, first, a section of the source will be shown, followed by a discussion of that section. The Imports import argparseimport jsonimport sysimport subprocessimport threadingfrom bluetooth import *from boltons.socketutils import BufferedSocketfrom python_banyan.banyan_base import BanyanBaseAt the top of the file, as is typical, all of the modules required by the Bluetooth Gateway are imported. If you followed the previous postings, any libraries required to be installed have already be installed.   Note: When importing the Banyan base class, use the syntax shown above. Declaring The BluetoothGateway Class class BlueToothGateway(BanyanBase, threading.Thread):All Banyan components inherit from the BanyanBase base class.In order to support bidirectionaldata transmission over the RFCOMM link, the BTG also needs to inherit fromthreading.Thread. A separate thread handles Bluetooth data reception. Thread creation and execution is accomplished in thestandard manner. The __init__ Method    def __init__(self, back_plane_ip_address=None, subscriber_port='43125',                 publisher_port='43124', process_name=None, loop_time=.001,                 gateway_type=BTG_SERVER, publish_topic=None,                 uuid='e35d6386-1802-414f-b2b9-375c92fa23e0',                 server_bt_address=None, subscriber_list=None,                 json_data=False):Here we see all of the parameters that the class accepts. We could have used  *kwargs here, but I think it is clearer to list everything out. All parameters are *key-word parameters, so all have a default value.         \"\"\"        This method initializes the class for operation        \"\"\"        # save input parameters as instance attributes        self.back_plane_ip_address = back_plane_ip_address        self.subscriber_port = subscriber_port        self.publisher_port = publisher_port        self.loop_time = loop_time        self.gateway_type = gateway_type        # set the name for the banner depending upon client or server        if process_name is None:            if self.gateway_type == self.BTG_CLIENT:                self.process_name = 'BanyanBluetoothClient'            else:                self.process_name = 'BanyanBluetoothServer'        else:            self.process_name = process_name        self.publish_topic = publish_topic        self.uuid = uuid        self.server_bt_address = server_bt_address        self.json_data = json_data        In the section above we save the input parameters as instance attributes so that theyare available to be used anywhere within the class. One of the parameters, gateway_type is used to define the process name that will be displayed when the Bluetooth Gateway is invoked.         # initialize the parent        super(BlueToothGateway, self).__init__(            back_plane_ip_address=self.back_plane_ip_address,            subscriber_port=self.subscriber_port,            publisher_port=self.publisher_port,            process_name=self.process_name,            loop_time=self.loop_time)Above we call super to initialize the BanyanBase parent.         self.subscriber_list = subscriber_list                        for topic in self.subscriber_list:                    self.set_subscriber_topic(topic)                    print('Subscribed to: ', topic)                print('Publish to   : ', self.publish_topic)In the code above we subscribe to the topics specified by calling set_subscriber_topic for each topic,and printingeach subscription topic to the console. The specified publishing topic is also printed to the console.         mac = self.find_local_mac_address()        if mac:            print('Local Bluetooth MAC Address: ', mac)        else:            print('No Bluetooth Interface Found - Exiting')            sys.exit(0)Here we self-discover the MAC address of the local Bluetooth interface and print it to the console. The find_local_mac_address method utilizes subprocess.Popen to execute an hcitool command to retrieve the MAC address.         if self.gateway_type == self.BTG_SERVER:            self.server_sock = BluetoothSocket(RFCOMM)            self.server_sock.bind((\"\", PORT_ANY))            self.server_sock.listen(1)            port = self.server_sock.getsockname()[1]            advertise_service(self.server_sock, \"BanyanBlueToothServer\",                              service_id=uuid,                              service_classes=[uuid, SERIAL_PORT_CLASS],                              profiles=[SERIAL_PORT_PROFILE],                              )            print(\"Waiting for connection on RFCOMM channel %d\" % port)            try:                self.client_sock, self.client_info = self.server_sock.accept()            except KeyboardInterrupt:                self.clean_up()                sys.exit(0)            print(\"Accepted connection from \", self.client_info) In the section of code above, we create a BluetoothServer and then wait for an incomingconnection.        else:            service_matches = find_service(uuid=self.uuid,                                           address=self.server_bt_address)            if len(service_matches) == 0:                print(\"Could not find the remote Bluetooth server - exiting\")                self.clean_up()                sys.exit(0)            first_match = service_matches[0]            port = first_match[\"port\"]            name = first_match[\"name\"]            host = first_match[\"host\"]            print(\"connecting to \\\"%s\\\" on %s\" % (name, host))            # Create the client socket            self.client_sock = BluetoothSocket(RFCOMM)            self.client_sock.connect((host, port))Above, if the Bluetooth Gateway was configured to be a client, the else path is taken.         # wrap the socket for both client and server        self.bsock = BufferedSocket(self.client_sock)        # create a thread to handle receipt of bluetooth data        threading.Thread.__init__(self)        self.daemon = True        # start the thread        self.start()        # this will keep the program running forever        try:            self.receive_loop()        except KeyboardInterrupt:            self.clean_up()            sys.exit(0)And in the last section of __init__ shown above, we wrap the socket with a Bolton BufferedSocket. We do this to simplify parsing JSON data if the BTG was configured for JSONencoding/decoding. We then initialize the parent Thread class and then start the thread to receive data from the Bluetooth connected device. Next, we startthe banyan receive_loop that keeps the program running while processingany incoming Banyan protocol messages. The incoming_message_processing Method     def incoming_message_processing(self, topic, payload):        \"\"\"        Process the incoming Banyan message to        be sent to the Bluetooth network        :param topic: topic string        :param payload: payload data        \"\"\"        # if the bluetooth device requires json encoding        if self.json_data:            data_out = json.dumps(payload)            data_out = data_out.encode('utf-8')            try:                self.bsock.send(data_out)            except Exception as e:                self.clean_up()                raise RuntimeError('Write Error')        else:            # convert the payload to a string            data_out = str(payload['report'])            data_out = data_out.encode('utf-8')            self.client_sock.send(data_out)The code above is the entirety of this method. It is automatically called by the base class when an incoming Banyan protocol messageis received. If the hardware interface component detects a status change on a GPIOpin, it may generate a Banyan message containing that change. The BTG can registerto receive status change messages and pass the change data to the Bluetooth device. The method checks to see if the JSON data option is enabled and if so, the data is JSON encodedand sent across the RFCOMM link. If JSON is not enabled, the report value is extracted, converted to a string,  encodedand sent across the RFCOMM link. The run Method     def run(self):        \"\"\"        This is thread that receives packets from the bluetooth interface        :return:        \"\"\"        while True:            # if json encoding look for termination character            # used for a dictionary            if self.json_data:                try:                    data = self.bsock.recv_until(b'}',                                                 timeout=0,                                                 with_delimiter=True)                except KeyboardInterrupt:                    self.clean_up()                    sys.exit(0)                except Exception as e:                    continue                data = data.decode()                data = json.loads(data)                self.publish_payload(data, self.publish_topic)            # data is not json encoded            else:                try:                    data = (self.client_sock.recv(1)).decode()                except KeyboardInterrupt:                    self.clean_up()                    sys.exit(0)                payload = {'command': data}                self.publish_payload(payload, self.publish_topic)Bluetooth data is received and processed by the thread implementation shown above.The data is either treated as JSON data or as string data depending upon the JSONcommand line option selected.  In either case, a Banyan protocol message is created containingthe data and then published to the Banyan network. Capturing User Specified Command-Line Options And Starting The Component def bluetooth_gateway():    parser = argparse.ArgumentParser()    parser.add_argument(\"-a\", dest=\"server_bt_address\", default=\"None\",                        help=\"Bluetooth MAC Address of Bluetooth Gateway\"),    parser.add_argument(\"-b\", dest=\"back_plane_ip_address\", default=\"None\",                        help=\"None or IP address used by Back Plane\")    parser.add_argument(\"-g\", dest=\"gateway_type\", default=\"server\",                        help=\"Type of Gateway : server or client\"),    parser.add_argument(\"-j\", dest=\"json_data\", default=\"False\",                        help=\"Bluetooth packets json encoded true or false\"),    parser.add_argument(\"-l\", dest=\"publish_topic\", default=\"from_bt_gateway\",                        help=\"Banyan publisher topic\"),    parser.add_argument(\"-m\", dest=\"subscriber_list\",                        default=[\"None\"], nargs=\"+\",                        help=\"Banyan topics space delimited: topic1 topic2 \"                             \"topic3\")    parser.add_argument(\"-n\", dest=\"process_name\", default=\"None\",                        help=\"Set process name in banner\")    parser.add_argument(\"-p\", dest=\"publisher_port\", default='43124',                        help=\"Publisher IP port\")    parser.add_argument(\"-s\", dest=\"subscriber_port\", default='43125',                        help=\"Subscriber IP port\")    parser.add_argument(\"-t\", dest=\"loop_time\", default=\".01\",                        help=\"Event Loop Timer in seconds\")    parser.add_argument(\"-u\", dest=\"uuid\",                        default=\"e35d6386-1802-414f-b2b9-375c92fa23e0\",                        help=\"Bluetooth UUID\")    args = parser.parse_args()    if args.back_plane_ip_address == 'None':        args.back_plane_ip_address = None    if args.server_bt_address == 'None':        args.backplane_ip_address = None    if args.gateway_type == 'server':        args.gateway_type = BlueToothGateway.BTG_SERVER    else:        args.gateway_type = BlueToothGateway.BTG_CLIENT    if args.server_bt_address == 'None':        args.server_bt_address = None    if args.process_name == 'None':        args.process_name = None    if args.subscriber_list == ['None']:        args.subscriber_list = ['to_bt_gateway']    if args.json_data == 'False' or args.json_data == 'false':        args.json_data = False    else:        args.json_data = True    kw_options = {        'back_plane_ip_address': args.back_plane_ip_address,        'publisher_port': args.publisher_port,        'subscriber_port': args.subscriber_port,        'process_name': args.process_name,        'json_data': args.json_data,        'loop_time': float(args.loop_time),        'publish_topic': args.publish_topic,        'gateway_type': args.gateway_type,        'uuid': args.uuid,        'server_bt_address': args.server_bt_address,        'subscriber_list': args.subscriber_list    }    BlueToothGateway(**kw_options)    # signal handler function called when Control-C occurs# noinspection PyShadowingNames,PyUnusedLocal,PyUnusedLocaldef signal_handler(sig, frame):    print('Exiting Through Signal Handler')    raise KeyboardInterrupt# listen for SIGINTsignal.signal(signal.SIGINT, signal_handler)signal.signal(signal.SIGTERM, signal_handler)if __name__ == '__main__':    bluetooth_gateway()Python Banyan Components typically allow a user to tune the component by specifyingcommand-line options when invoking the component. This is accomplished within theblue_tooth_gateway function, using the argparsemodule. In addition to handling command-line options, the BluetoothGateway class is also instantiatedwithin this function. Notice that this function and everything below it is outside of the definition of the BluetoothGateway class. Below the blue_tooth_gateway function, there is a signal handler to trap Control-C presses, SIGTERM and SIGINT signals. And the very last line calls the bluetooth_gateway function to instantiate the gateway.   Installing a component as a command-line executable:The code below the BluetoothGateway class definition is written using a specific stylized structure and is common in many of the Banyan components. This allows one to  easily  transform a component into a command-line executable. Keeping in line with the Banyan design philosophy, the BluetoothGateway is a componentthat is very limited in scope. In total it has less than 150 executable statements.As a result, testing is simplified, and the possibility of reuse increased.As we look at other examples of Banyan components in future posts, we will seea lot of similarity in file structure. Using common Banyan coding patterns when developingBanyan components aids in the rapid development of quality code. Next Time Next time, we will test the Bluetooth Gateway and learn about BlackBox and WhiteBoxtesting. We will learn how to use the Banyan monitor to view Banyan messagesas they are published, and how to use the Banyan launcher to launch severalcomponents and tools from a single command line, making testing simple andreproducible. ","categories": ["banyan-components","bluetooth-gateway"],
        "tags": ["threading","banyan","coding-convention"],
        "url": "http://localhost:4000/bots-in-pieces/banyan-components/bluetooth-gateway/2019/07/09/banyan-bot-blue-part5.html"
      },{
        "title": "Banyan Bot Blue Part 6",
        "excerpt":" Testing The Bluetooth Gateway      In this edition of Bots In Pieces, we will:   Test The Bluetooth Gateway:          Install the necessary software for testing on the Raspberry Pi.      Discuss the Banyan Backplane.      Learn how to use the Banyan Monitor and Message Injector tools to aid in testing.      Use previously tested items as test drivers and monitors to accelerate the test cycle.      Discuss the Python Coverage tool.      Learn how to automate the tests procedures using the Banyan Launcher as a test runner.        Presented here is my approach to testing Python Banyancomponents. Note that the Banyan Framework does not inhibit the use of any testing techniques or test runners. You are freeto use any tools or techniques with which you are comfortable. Some Test Preliminaries If you have not already done so, install Python Banyan on the Raspberry Pi by openinga command window and typing: sudo pip3 install python-banyanNext, we need to install the Banyan Bot Blue project files on the Raspberry Pi. On your Raspberry Pi, open the browser and go to the bots-in-pieces-examples GitHub page.Click on the green Clone or download button on the page. Unzip the file into any directoryyou wish. Here is a representation of the file structure after you extract the zip file: bots-in-pieces-examples-master├── banyan-bot-blue│   ├── android│   │   ├── b_bot_blue.aia│   │   └── b_bot_blue.apk│   ├── banyan_assets│   │   ├── bluetooth_gateway.py│   │   ├── crickit_gateway.py│   │   ├── __init__.py│   │   └── robot_control.py│   ├── banyan_templates│   │   ├── banyan_component_template.py│   │   └── __init__.py│   ├── __init__.py│   ├── test_fixtures│   │   ├── bluetooth_apk_validation_server.py│   │   ├── crickit_gui.py│   │   ├── __init__.py│   │   ├── json_server.py│   │   ├── message_injector.py│   │   └── rfcomm_server.py│   └── tests│       ├── bluetooth_gateway│       │   ├── btg1.csv│       │   ├── btg2.csv│       │   ├── btg3.csv│       │   ├── btg4.csv│       │   ├── btg5.csv│       │   ├── __init__.py│       │   ├── procedures│       │   │   ├── btg1.test_spec.pdf│       │   │   ├── btg2.test_spec.pdf│       │   │   ├── btg3.test_spec.pdf│       │   │   ├── btg4.test_spec.pdf│       │   │   └── btg5.test_spec.pdf│       │   └── test_results│       │       ├── btg1_2_3_4_5_results.pdf│       │       ├── btg1_2_3_4_5_summary.pdf│       │       ├── btg1_2_3_4_results.pdf│       │       ├── btg1_2_3_4_summary.pdf│       │       ├── btg1_2_3_results.pdf│       │       ├── btg1_2_3_summary.pdf│       │       ├── btg1_2_results.pdf│       │       ├── btg1_2_summary.pdf│       │       ├── btg1_results.pdf│       │       └── btg1_summary.pdf│       ├── crickit_gateway│       │   ├── cr1.csv│       │   ├── __init__.py│       │   └── test_results│       │       ├── cr1_results.pdf│       │       └── cr1_summary.pdf│       ├── __init__.py│       └── motor_control│           ├── __init__.py│           └── mc1.csv├── LICENSE└── README.mdNext, we need to install xterm on the Raspberry Pi. Open a command window on the Raspberry Piand type: sudo apt-get install xtermLastly, we need to install the Python Coverage tool. In the command window, type the following: sudo apt-get install python3-dev gccThen type: sudo pip3 install coverageThe Banyan Backplane When a Banyan component initializes, it attempts to connect to the Banyan Backplaneusing two TCP/IP connections, onefor message publishing and one for message reception.The backplane is a command-line executable, automatically installed with Python Banyan.To launch the backplane,open up a terminal window on the Raspberry Pi and type: backplane When the backplane starts, a familiar Banyan header prints to the console. Before launching any other Banyan component, you must run the backplane. If the backplane is not running when launching a Banyan component, an exception and error message are displayed.   The Banyan Monitor The Banyan Monitor is a specialized Banyan component that allows you to view allpublished Banyan messages. The monitor is a command-line executable, automatically installed with Python Banyan. To run the monitor, while the backplane is running, open a new command window and type: monitor Again we see the familiar Banyan header, but since there are no published messages, that is all we see. Let’s remedy that by starting a Banyan component that publishes messages periodically. The Message Injector Component To demonstrate the monitor, we launch a test fixture used to help test the Banyan Gateway. This Banyan component, unlike the backplane and monitor,is not a command-line executable, so we need to launch it manually.  We find the message injector in: bots-in-pieces-examples-master/banyan-bot-blue/test_fixturesThis component periodically injects Banyan messages into the network. It has a defaultpublishing topic of to_bt_gateway. It also subscribes to receive messages with a topic offrom_bt_gateway. With both the backplane and monitor running, let’s launch the message injector. Opena new command window, cd into the directory shown above and type: python3 message_injector.py Again, we see a familiar Banyan header with the addition of the publishing and subscriptiontopics announced. Look at the monitor window, and you should see injector messages appear as they are published.  Each line in the monitor window represents a single Banyan protocol message, andit contains both  the publishing topic and the message’spayload. The Banyan Launch Server I don’t know about you, but having to manually open several command windows and then individually interacting with each one, is not my idea of fun. Using the Banyan Launcher, the backplane, the monitor,the message_injector, and the bluetooth_gateway are all launched from a single command. Understanding The Banyan Launcher The Banyan Launcher Server(bls) is a command-line executable, automatically installed with Python Banyan.  To use the launcher, you must firstpopulate a comma-delimited or csv file.This file,called the launch specification file, contains a list of the items to be launched and their associatedlaunch instructions. The first line of every launch specification is a comma-delimited list ofcolumn headings: command_string,spawn,topic,append_bp_address,auto_restart,waitA set of launch specifications, one launch item per line, follows the column headings.   NOTE: There must not be any spaces before or after the commas on any lines of thespecification file. The Launch Specification Field Headings command_string In this field, you specify the shell command used to launch the item.The example below is the command string to launch the message_injector. Notice that it uses relative addressing to find the file because our test runs in the following directory: bots-in-pieces-master/banyan-bot-blue/tests/bluetooth_gateway Example: python3 ../../test_fixtures/message_injector.pyspawn The values for this field are either yes or no. If set to yes, each commandruns in a stand-alone xterm window. topic Set this field to local. The Banyan Launcher can launch commands on a remote computer.  In the remote launch scenario, we set this field to something other than local. append_bp_address The values for this field are either yes or no. For our purposes, set this field to no.This field would be set to yes when launching on a remotecomputer, and we wish to inform the remote computer of the backplane address of the localcomputer. auto_restart The values for this field are either yes or no. If set to yes, the launcher automatically restarts the command if it shoulddie for any reason. We set this to no. wait This field specifies a period in seconds to wait before launchingthe next command in the file. The wait field allows the commandto initialize fully before processing the next launch line. A Sample Launch Specification btg1.csv Here are the contents of btg1.csv,a test that runs the Bluetooth Gateway, accepting its default parameters.  The first line launches the Banyan Monitor, the second line launches the Bluetooth Gateway, accepting all its default parameters, and the third line launches the message_injector.   When using the Banyan Launcher, it automatically launches the backplanewithout having to specify the backplane in the launch specification file. Code Coverage We can test the Bluetooth Gateway by stimulating both of its interfaces, that is,its RFCOMM interface as well as its Banyan protocol messaging interface.We then observe the results of this stimulation and compare that to the expected results.Sometimes this type of testing isreferred to as BlackBox testing.BlackBox testing tests an item’s behavior but provides no information about what is happeninginside the item under test. WhiteBox testing provides an internal code view ofthe unit under test.A form of WhiteBox testing is calledcode coverage. Code coveragedetermines which statements in a body of code have executed through a test run, and which statements have not. In general, a code coverage system collects information about the running program and then combines that with source information to generate a report.The tool used to perform coverage testing is thePython Coverage Tool. By combining the results from both BlackBox and WhiteBox testing, we can determineif the unit under test is operating correctly. Testing With The Coverage Tool To enable coverage testing for  bluetooth_gateway.py, we issue the following command: \"sudo coverage run --branch  --append --omit=/usr/lib*,/usr/local* ../../banyan_assets/bluetooth_gateway.py\"Notice that we enclose the entire command in quotes. The bash shell requires this so that it may successfully parse and execute the command. The Coverage Command In Detail The command requires sudo because the Bluetooth library requires it. The next portion of the command is coverage run. The run option instructs the coverage tool to instrumentthe code and to execute the module. The --branch option enables branch coverage. Branch coverage allows us to see the executed and non-executed legs of a branch. The --append option tells coverage to append the results of the current test to previous results. This option allows us to run several different tests on the gateway,and then be able to view a single report showing the aggregated results from all the tests. The --omit option limits coverage testing to only the files we wish to test. Finally, we specify the path and file name for the unit under test. Getting The Coverage Results The coverage tool can generate HTML coverage reports. To generate HTML reports, weuse the following command: coverage html -d coverage_htmlBy executing this command, coverage creates and populates a directory called coverage_html, allowing us to display the report in a Web browser. To view the generated report,open up index.htmlin the coverage_html directory using your favorite Web browser. Coverage Summary Report  We see a summary report when opening index.html.The report shown above is the result of running the btg1.csv test specification. The report indicates that the unit under test had 153 executable linesof code and an execution rate of 68%. By clicking on the link in the summary report, we can view the detailed coverage report. Coverage Detailed Report Below is a portion of a detail report that the coverage tool generated:  The report is color-coded. A green bar next to a line of code indicates the line executed; a red bar means that line did not execute, and a yellow bar means that a branch partially executed. The coverage tool allows you to accumulate test results as each test is run and then generate an aggregated report of all the test runs. It is good practice to save the test reports for comparison with future test runs. Test Evaluation Notice when viewing the full detailed reportfor btg1.csv, the lines of code that were not executed fall into two categories. The first being the paths that support the command-line options we did not use, and the second, the exception paths. By examining this report, we can determine that the executed code is sufficient to support theBanyan Bot Blue, even though it is only 68% of the total. Since the Bluetooth Gateway was writtento be configurable through its command-line options, we can add additional tests that thoroughly test the file, andfour additional tests were devised to do just that. If you look at the detailed report for the aggregated results,coverage achieved is 88%. The 12% of the code not covered were for the exception cases. For ourpurposes, 88% coverage is a good passing percentage. Documenting Test Procedures Before starting to test, it is beneficial to document the specifications and procedures foreach test to be run.I do this in a somewhat formalized way, and each specification typically contains:   The purpose or scope of the test.  A list of items and prerequisites necessary to run the test.  The test procedure.I like to include hyperlinks within the spec to provide any supportingdocumentation that might be helpful.Here is an example of a test specification for testing the Bluetooth Gatewayaccepting all default command-line parameters. When you open the file in GitHub, the links are not active, but if you open the file in thedistribution you downloaded from GitHub, the links are functional. Running The Test With The Banyan Launcher Now that we understand all the tools used in testing the Bluetooth Gateway let’s runa test using the Banyan Launcher(bls). Here are the steps to do so:       Close all the command windows we opened previously.     Open a new command window and go to    bots-in-pieces-examples-master/banyan-bot-blue/tests/bluetooth_gateway        Run the Banyan Launcher using the -f option to specify the test specification file:    bls -f btg1.csv             The command window displays that bls launched the backplane, monitor, bluetooth_gateway, and themessage_injector, showing the process ID or PID for each. It also opened up 3 additional xterm windows,one each for the monitor, bluetooth_gateway, and message_injector.If you look at the monitor window,the injector messages appear.   We now want to connect the Android app as discussed in a previous posting.Start the app and connect it to the Raspberry Pi. The bluetooth_gateway window should indicate that the connection succeeded. After connecting the app, you should see the value in the Report line change as each message fromthe message injector is received:    Now press the Android app buttons. If you look at the monitor window, you should see both the messages that were published by themessage injector as well as the messages published by the Bluetooth Gateway.   If you look at the message_injector window, you should see the messages from the Bluetooth Gatewayas well. The message injector subscribed to receive those messages. Verify that for each button pressed in theAndroid app generates the expected messaging. Why Manual Interaction And Not Total Automation? At some point in the testing cycle, you must verify that user interfaces workas expected. Adding mock type automation adds an unnecessary step, so why not testthings out as early as possible. Since we tested the Android app in an earlier posting, we can now use it as a test driver. If we do not have a tested component to run portionsof the test, only then do we create a mocking type component. The message injector isan example of this. Stopping The Test And Getting Results To stop the test, go into the Bluetooth Gateway xterm window and type Control-C to stop it. We need to stop the gateway within this window to allow the coveragetool to terminate properly and provide results. If you then go into thebls command window and press Control-C, all the other xterm windows should close. Now generate a test report as described above to verify expected code execution. Summing Up Using the tools and techniques presented in this posting, we demonstrated that Banyan components are testable in an easily reproducible manner. We demonstrated that previously tested components are practical testing drivers and monitors. We also demonstrated the ease of integrating custom test tools, such as the message injector, into the testing suite. Next Time In the next posting, we discuss the Crickit Gateway component that monitors and controlsthe robot motors and sensors. ","categories": ["banyan-components","bluetooth-gateway"],
        "tags": ["testing","banyan-monitor","banyan-launcher","message-injector","whitebox","blackbox","coverage"],
        "url": "http://localhost:4000/bots-in-pieces/banyan-components/bluetooth-gateway/2019/07/19/banyan-bot-blue-part6.html"
      },{
        "title": "Banyan Bot Blue Part 7",
        "excerpt":"Direct Hardware Control   In this edition of Bots In Pieces, we will:   Discuss controlling motors and sensors using Python Banyan:          Create a Banyan OneGPIO Gateway that directly interacts with thehardware.      Create a Tkinter test fixture to test the gateway.       Hardware Monitoring And Control When choosing a hardware interface to use, you may consider designingand building a custom interface using discrete components or, you mightuse a more integrated approach, such as aRaspberry Pi HAT. The custom approach allows the flexibility of choosing each of thecomponents, but you are also responsible for both physical andelectrical design.            DiscreteComponent Approach               IntegratedApproach For the Banyan Bot Blue project, the integrated approach was chosen,taking advantage of theAdafruit Crickit HAT, thereby greatly simplifying physical and electrical design and construction.  The Banyan OneGPIO Gateway Concept Now that we’ve selected a hardware interface, we need a Banyan componentto control and monitor that interface. The function of this component isto translate Banyan messages to and from hardware-specific API calls.From the Banyan perspective, a standard messaging specification, calledOneGPIO, is usedto describe all hardware interactions. Because all Banyan hardwareinterface components employ the OneGPIO message specification, we callthis type of component a Banyan OneGPIO Gateway. A Banyan OneGPIO Gateway consists of 2 major parts, a consistent Banyaninterface that all OneGPIO Gateways share, and a hardware-specificsection that allows direct hardware monitoring and control.  All OneGPIO Gateways derive from a standard base class, calledGatewayBase.The GatewayBase class ensures that the Banyan OneGPIO protocol messages are processed consistently. The OneGPIO messagingprotocol is a hardware-independent abstraction of hardware and GPIOcontrol and monitoring. The role of the OneGPIO Gateway is to convertthis abstract view to direct hardware control for each supportedhardware type. By using the Banyan OneGPIO Gateway approach, the actual hardware isloosely-coupled from the rest of the application. So, if you wish to gofrom one hardware platform to another, you need only swap out one BanyanOneGPIO Gateway for another, without having to recode any of the othercomponents. There are OneGPIO Gateways available for theRaspberry Pithat utilizes the pigpio API, forArduino microcontrollers,that uses Pymata-Express,and for theESP-8266that makes use of a board residentmicropython API.  For this project, we create an additional OneGPIO Gateway, the CrickitHAT Gateway, that expands Banyan support for the Raspberry Pi. With thisadditional gateway, you now have the choice to use discrete componentsor the HAT approach for hardware design. The Crickit OneGPIO Gateway Before getting into some of the details of coding the Crickit HardwareGateway, let’s take a look at the Crickit’s capabilities. Crickit HAT Capabilities The Crickit HAT supports the following functionality:   8 Input/Output Channels          Each individually configurable for input as:                  Digital Input          Digital Input/Pull Up          Analog Input          Digital Output                      4 Touch Inputs  8 Digital Outputs  4 “Drive” Outputs          For controlling items, such as solenoids      Can be used for PWM output        2 D.C. Motor Controllers  4 Servo Motor Controllers  2 Stepper Motor Controllers  1 Neopixel Controller  I2S Speaker Output  Note: The Cricket OneGPIO Gateway supports all of these capabilities,except for the I2S speaker output. The Adafruit web site warns ofseveral caveats about Raspbian support for this feature. You mayenable the I2S feature, but the OneGPIO Gateway does not directlysupport it. In reality, the Banyan Bot Blue has very modest needs compared to theCrickit HAT’s capabilities. We only need to control 2 motors, both forspeed and direction and to monitor 2 bumper sensors, for when the robotbumps into something. So why create a OneGPIO Gateway for virtually allof the Crickit HAT’s capabilities when only a small subset is needed?The answer is simple. If all the features are supported, then in thefuture, if we need to use features over and beyond the needs of theBanyan Bot Blue, we do not need to go back into the code and potentiallybreak something that is already working. The motto here is: “Write once,test once, and reuse many times.” Supporting OneGPIO As mentioned earlier, all Banyan OneGPIO Gateways support a standardizedprotocol messaging specification known as OneGPIO. To accomplish this,and to make coding more straightforward, the GatewayBase class providesa coding template to enforce consistency across all Banyan HardwareGateways. To better understand the CrickitGateway, it is essential to understand the inheritance hierarchy that all Banyan OneGPIO Gateways employ. For more detail about the code, click on the links below. The Crickit Gateway Inheritance Hierarchy  At the top of the hierarchy is theBanyanBase class.Every Banyan component derives from this base class. The BanyanBaseclass is responsible for network connectivity, formatting and publishingBanyan protocol messages, and decoding received Banyan protocolmessages. TheGatewayBase classis directly below and derived from the BanyanBase class. The GatewayBaseclass defines the standard programming interface for managing OneGPIOprotocol messages. The GatewayBase Class maintains alook-up dictionaryto route a OneGPIO message to its handler. Thehandlers in the base class are empty and mustbe overwritten in the class implementing the OneGPIO Gateway. Below the GatewayBase class is the hardware-specific OneGPIO Gatewayclass. In the case of the Crickit Gateway, it translates the OneGPIOmessages into method calls for theAdafruit Cricket Library. Because it is impossible to know all future hardware messaging needs,the OneGPIO message specification was designed to be extensible. You canexpand upon the OneGPIO message set by merely creating a new message.When a message is received by a OneGPIO Gateway that is not a member ofthe OneGPIO specification, that message is passed to and processed by the derived message handler method called additional_banyan_messages. Adding functionality to the OneGPIO specification is as simple asdefining a new message, and processing that message in the additional_banyan_messages method without having to modify the GatewayBase class.  For example, the Cricket Gateway handlesmessage requests for D.C. and stepper motor control as well as neo-pixelsupport within itsoverwritten additional_banyan_messages method. The Adafruit Cricket Library, unfortunately, does not provide for callback notifications when input values change. Instead, one must poll the inputs for change. The Crickit Gateway uses a separate thread to poll the inputs and publishes a value change message if the value for a given input changes from the previous poll. It also provides a timestampas to when the change occurred, this way cutting down redundantmessaging. Testing The Crickit Gateway To test all of the Cricket Gateway’s functionality, we employ a BanyancompatibleGUI test fixture.  Banyan And Tkinter Coexistence Both Banyan and Tkinter use dedicated event loops to process messagesand events. We need to find a way for each of these loops to coexistwithout blocking one another. To solve this dilemma, we run the Tkinter event loop, but haveit periodically call a method that performs the function of theBanyan receive_loop.The get_messagemethod is added to the GUI application to emulate the Banyan receiveloop. The get_message method isexecuted regularlywithin the Tkinter main_loop by using the Tkinter“after” method. The GUI Selection Tabs The GUI has 8 tabs, each one dedicated to a Crickit functional group.Above, we see the Signal Inputs tab selected and that for Signal 1 and2, the time that their respective values changes. The bumper switchesconnect to these signals. You can view screenshots for all eight tabs below.        To launch all the test components, make sure that you have the latestversion of bots-in-pieces-examples. On your Raspberry Pi, open the browser and go to thebots-in-pieces-examples GitHub page.Click on the green Clone or download button on the page. Unzip thefile into any directory you wish. To start the test files, open a new command window and go to: bots-in-pieces-examples-master/banyan-bot-blue/tests/crickit_gatewayNext, run the Banyan Launcher using the -f option to specify the testspecification file: bls -f cr1.csvTo perform the tests, you interact with theGUI, observe the hardware’s behavior, and compare it to the expectedbehavior. You can create a coverage report using the command: coverage html -d coverage_htmlNext Time Next time we cover the robot component, the brains of the application. ","categories": ["banyan-components","cricket-hardware-gateway"],
        "tags": ["tkinter-gui-testing-fixture"],
        "url": "http://localhost:4000/bots-in-pieces/banyan-components/cricket-hardware-gateway/2019/08/15/banyan-bot-blue-part7.html"
      },{
        "title": "Banyan Bot Blue Part 8",
        "excerpt":"Wrapping Up The Project With Robot Control                 In this edition of Bots In Pieces, we will:   Wrap up the Banyan Bot Blue Project          Create the final component - the robot controller.      Show you how to launch the application:                  From the command line          At boot time          Without being connected to your LAN                    The Banyan Robot Controller Component Currently, we can send and receive raw commands to and from an AndroidJoypad App. We also can control a robot’s 2 D.C. motors and 2 bumperswitches through a Crickit HAT. What we don’t have is a way to connectthe Android App to the Crickit HAT. The Banyan robot controllercomponent provides that interconnection. The robot controller will:   Accept raw motor control commands generated by the Android App andtranslate those commands into OneGPIO control messages for the CrickitGateway to process.  Monitor the bumper switches and autonomously adjust the robot’s motionwhen the robot bumps into an object. When a bumper switch fires, therobot runs in reverse for approximately 1 second.The Robot Controller subscribes to receive generic robot controlcommands. It translates and publishes those commands as OneGPIO protocolmessages that the hardware control component can use to control therobot. It also subscribes to receive any report data that the hardwarecontrol component publishes, such as bumper sensor data. It uses thatdata to affect robot motion autonomously.  Using A Dictionary To Dispatch Processing Of The GUI Commands The robot control component is a typical Banyan component, with onepossible notable exception. The Android App publishes user commands as single-character messages,namely, “U, u, D, d, L, l, R, r, S, s, and W, w,” as explained in aprevious posting. To determine how to process each command, we could use a long list ofif/elif statements, but a more elegant approach is to place the commandsin an iterable data structure that describe the motor protocol messagesfor each command. This data structure is namedmotor_control_payloads.When a command is received, a routine looks up the command andretrieves its associated motor commands. The structure may seem complicated, but in reality, it is very straightforward. Essentially it is a list. Let’s look at an element ofmotor_control_payloads to understand how it works. Each list element contains a dictionary item with the command as itskey. Below is the entry for the ‘U’ command to move the robot forward.The value of the dictionary entry consists of an array of 2 OneGPIOmessages, one to control the left motor and the other for the rightmotor.     # forward    {'U':        [            {'command': 'dc_motor_forward', 'motor': 1,             'speed': self.forward_speed / self.speed_scaling_factor},            {'command': 'dc_motor_forward', 'motor': 2, 'speed': self.forward_speed / self.speed_scaling_factor}        ]    },Here is the code to iterate through motor_control_payloads:     # Find the messages for the key command and publish    # the commands to the motor controller.    for record in range(0, len(self.motor_control_payloads)):        if key in self.motor_control_payloads[record]:            motor_commands = self.motor_control_payloads[record]            payload = motor_commands[key][0]            self.publish_payload(payload, self.publish_to_hardware_topic)            payload2 = motor_commands[key][1]            self.publish_payload(payload2, self.publish_to_hardware_topic)This routine checks to see if the command is in the array:     for record in range(0, len(self.motor_control_payloads)):            if key in self.motor_control_payloads[record]:If it is, it retrieves the entry for the command:                 motor_commands = self.motor_control_payloads[record]Each entry contains a list of 2 OneGPIO protocol messages for motorcontrol. Each command is retrieved and then published.                  payload = motor_commands[key][0]                            self.publish_payload(payload, self.publish_to_hardware_topic)                            payload2 = motor_commands[key][1]                            self.publish_payload(payload2, self.publish_to_hardware_topic)This is a lot less code to maintain then using a very long chain ofif/elif statements. Running The Application You can run the application either from the command line or automatically start it at boot-time.   Note: There have been some changes made to some of the files sincethe previous posting. Please download the files once again by clickingon this link togo to the repository web page. Next, click the on the green downloadbutton and finally unzip the file. The distribution includes a .zipfile that contains all the files you need to run the application.Please unzip the file calledfinal_files.zipin your home directory. From Command Line   Tip: If you run the Raspberry Pi in a headless mode usingVNC orxrdp, you canstart the application remotely without having to attach a keyboard andmouse to the Raspberry Pi resident on the robot. To start all the components from a command shell, type the following command: bls -f bbot.csvThen using your Android device, connect the Android to the Raspberry Pi,and you are all set to go. At Boot-Time To have the application automatically start at boot time, first, changethe permissions on bbot.sh contained in final_files.zip. chmod ugo+x bbot.shIf your home directory is something other than /home/pi, edit bbot.shwith paths to your home directory. Next, open rc.local for editing.   NOTE: I am using vi as the editor, but use any editor you wish, and make sure to use the sudo command. Now when your Raspberry Pi boots, the Banyan-Bot-Blue application automatically starts. sudo vi /etc/rc.localDirectly above the exit 0 line at the bottom of the file, add thefollowing line: /home/pi/bbot.shAgain, adjust the path to your home directory if necessary. A Nice Bonus - No WiFi Router Needed! One of the features of Python Banyan is that if no WiFi is detected, allthe Banyan components default to using localhost or 127.0.0.1 as the IPaddress. Since all of the components for Banyan-Bot-Blue reside on asingle computer, they still can publish and subscribe to messageswithout the need of having to be connected to a WiFi network. The Wrap Up We covered much ground in this and the previous postings. We learned howto create, load, and pair a simple Android robot control App with theRaspberry Pi. We learned about Python Banyan and its concept of Protocoland Hardware Gateways in addition to the OneGPIO messagingspecification. Hopefully, you found this series of articles, bothexciting and informative. Lessons Learned   A Disclaimer: I do not receive any components from anymanufacturer either free of charge or on a trial basis. I purchaseeverything I use. All opinions about any of the products I use are myown. I attempt to be as objective as possible. One lesson I learned is that I should have tested the Crickit HAT using battery power well before the conclusion of this project. The Crickit HAT is excellent for projects powered from a high current source, but when powering from 4 NiMh AA cells, as recommended by Adafruit, the batteries die within minutes. Although not necessarily a gating factor, I believe the support libraries are somewhat lacking. The libraries do not provide a callback mechanism for input changes, forcing one to poll the inputs. Moreover, for some strange reason, when instantiating the stepper motor objects within the library, the motors are automatically powered. If you should happen to have a D.C. motor connected to the pins that support both stepper and D.C. motors, the D.C. motor is activated if you create an instance of the stepper motor object. What should be done, in my opinion, is provide a method call to power the stepper upon demand. Its initial state should be off. However, in spite of these objections, the shortcomings of the support software are not enough to prevent one from using the Crickit. As mentioned in a previous posting, the Crickit solves physical designissues very nicely, simplifying wiring significantly. So from this pointof view, I can recommend the Crickit if used with a current source thatcan provide 2.5 amps of continuous power. Next Time In the next edition of Bots-In-Pieces, we introduce the Banyan Bot BlueToo, where we exchange the Crickit Hat for aPimoroni Explorer HAT Pro.Hopefully, the Explorer HAT fairs better when using battery power thanthe Crickit HAT. ","categories": ["banyan-components","robot-control"],
        "tags": [],
        "url": "http://localhost:4000/bots-in-pieces/banyan-components/robot-control/2019/08/22/banyan-bot-blue-part8.html"
      },{
        "title": "Bayan Bot Blue 2 - Explorer Edition",
        "excerpt":"Replacing The Crickit With The Explorer Pro             In this edition:   We substitute the Pimoroni Explorer Pro for the Crickit HAT anddiscuss:          The experiences of performing the substitution.      Creating a Banyan Hardware Gateway for the Explorer Pro.      Changes needed in the other Banyan components.      Controller board recommendation.      Replacement Experiences First,the robot had to be rewired to meet the physical needs of the ExplorerPro. Then, a new Banyan Hardware Gateway module was created tosupport the Explorer Pro Python library. Both modifications were relatively simple andstraight forward. Battery Experience The Explorer Pro was easily powered using 4 NiMH AA cells. I left bothmotors running continuously for 10 minutes, and the batteries had moreto give. The Crickit HAT, on the other hand, lasted less than twominutes without the motors running using the same batteries. Rewiring Experiences The Explorer Pro, from a physical design point of view, is in my opinionnot as convenient as that of the Crickit. The Crickit offers +5 andground pins for each of its inputs and outputs and provides for screwterminals for its motor connections. The Explorer Pro does not offerscrew terminals, but in all fairness, the motor leads never dislodged.Both +5 and ground had to be broken out to the included mini-breadboard.Not a significant problem, but this increased chances for a wiring errorand a somewhat physically uglier outcome. Certainly not a deal-breaker. Creating an Explorer Pro Banyan Gateway CreatingExplorer Pro Gateway, was not particularly challenging and followed the pattern of a typicalBanyan Hardware Gateway.It takes advantage of the Python library supplied by Pimoroni. Explorer Pro Capabilities Here is a list of capabilities of the Explorer Pro HAT. These far exceedthe needs of the project, but the gateway supports all of thesefeatures. All were tested and worked flawlessly.   Four buffered 5V tolerant inputs.  Four powered 5V outputs (up to 500mA total across all four channels).  Four capacitive touchpads.  Four capacitive crocodile clip pads.  Four LEDs.  Four analog inputs.  Two H-bridge motor drivers (up to 200mA per channel; soft PWM control)A Tkinter GUI is provided to aid in testing. Handling “Chatty” Analog Inputs And Testing Anomalies The gateway supports all of the Explorer Pro features. For analoginputs, because they can be quite “chatty,” a differential thresholdmechanism was added to allow you to specify how much of a change ininput voltage must occur before publishing a value change notification.You may specify a different value for each of the 4 analog inputs. Usethe “-t” command-line option to specify the threshold values. Thedefault values are 0.3 volts. Also, because the Banyan Bot Blue does not require the use of analoginputs, analog inputs are disabled by default. To turn them on, use the“-a true” command-line option when starting the gateway.For testing,the test makes sure that analog inputs are enabled. Issues There were 2 issues discovered using the Pimoroni library whenhandling analog input. First, upon occasion, an erroneous value of 12volts was returned. The gateway prevents this erroneous value from beingsent to the robot_control component by “throwing out” any value over 5.1volts. The second issue appears to be related to the library’s threadingimplementation for input values. Input values seemed to clobber oneother, so I added a Python recursive lockto protect all input handlers. The data clobbering problem was solvedalthough the analog inputs are still chatty. In testing, for some unknown reason, coverage indicated that the digital input code did not execute. Digital inputs do work correctly but required physical observation to verify. Effect On Other Banyan Components For The Project Because the Explorer Pro gateway supports the OneGPIO specification, noother components needed to be modified or replaced. They all work “outof the box, supporting the “Write Once” philosophy. Controller Board Recommendation For battery powered projects the winner is The Pimoroni Explorer ProHAT. In spite of its minor shortcomings it is a delight to use. Banyan Bot Blue Comes To A Close The Banyan Bot Blue project was designed to illustrate the flexibility and reusable nature of Python Banyan components. I hope that you try Python Banyan and OneGPIO for your next project, and see how easy it is to create an application with a set of reusable Banyan components. ","categories": ["banyan-components","robot-control"],
        "tags": [],
        "url": "http://localhost:4000/bots-in-pieces/banyan-components/robot-control/2019/09/08/banyan-bot-blue-too.html"
      },{
        "title": "Creating a Scratch3 Extension For GPIO Control - Part 1",
        "excerpt":"First Steps     A Little Background These days, we don’t think twice aboutvisual programming languages, but when Scratch came on the scene, it wastruly radical. Since its inception, Scratch has brought the joys ofprogramming and creative thinking to millions. It may look like a kidstoy, but don’t let that fool you. It is a real programming language andprogramming environment that has captured the hearts of children andadults alike. Beware, if you haven’t played with Scratch before, you maybecome addicted.  After introducing Scratch 2, the first Web-based version of Scratch, theScratch team provided a specification forextending Scratch’sfunctionality by allowing a user to add custom programming blocks to theblock pallet. Shortly after the first Extension Specification For Scratch 2 waspublished, I created an extension that allowed a user to program,control, and monitor an Arduino board usingScratch blocks. This program was calleds2a, or Scratch To Arduino. Theoriginal protocol used to connect Scratch to an external application wasa JSON messaging protocol. This scheme tended to be quite slow, so theScratch team replaced JSON with HTTP providing a much-needed speedboost. I was there for that interface as well, withs2a_fm, aFirmata based interface, followedby its successor, s2aio. The aiopart of its name refers to the Python asyncio library of which s2aiotakes advantage. Over the years I have developed Scratch extensions forthe micro:bit, and even put togethera tutorial for those wanting tocreate their own Scratch 2 extensions for the Raspberry Pi.  At the beginning of 2019, the Scratch team released Scratch 3.0 thatincludes many improvements over Scratch 2.0. Of course, I wanted to getin on the Scratch 3.0 action. And So It Begins Building an extension for Scratch 2 was reasonably straight forward.When I went to explore theScratch 3 Extension Specification,I found it somewhat bewildering. It is early days for Scratch 3.0, sothis is not unexpected. I tried following the instructions, and although I could build parts ofthe system, I was unsuccessful at adding custom blocks. That isuntil I found a brilliant article written by Hiro Osaki, entitled,“How to Develop Your Own Block for Scratch 3.0”. Hiro explains the details of creating an extension, step by step. If you would like to understand the code structure I am using, readHiro’s article. I replaced the files of his newblocks extension withmy own named onegpio. I encountered some issues along the way, and when I contacted Hiro forsome guidance, he was more than happy to try and help. In that spirit, Iwould like to pass on my experiences. Goals Of The Extension Continuing with my passion for connecting Scratch to physical computingdevices, this extension, allows you to remotely program,control, and monitor an Arduino, ESP-8266, or Raspberry Pi. In previousposts, we used Python Banyan and its OneGPIO components.A thoroughly tested set ofPython Banyan/OneGPIO components is included with thes3onegpio GitHub distribution. Setting Up A Development Environment What You Will Need:   A computer running Linux (I use Ubuntu 19.04), Mac or Windows.          As an IDE, I use WebStorm, but a simple text editor will work aswell.                  Please note that I do not have access to a Mac so I have notpersonally tested things using a Mac. However, Hiro has, and sothere should be a minimal risk if your development environmentincludes using a Mac.                       For Windows,install the Windows Subsystem For Linux (WSL).           I tried Cygwin, but it did not work in this application for  me.      All work is done within WSL.      You may use Visual Studio Code in conjunction with WSL, but that      is beyond the scope of this discussion.        Nodejs and npm. Any version greater than version 8 for node.js isacceptable                  To check to see if you have node installed, in a terminal window orWSL type:         node -v                 This displays the node version. If node is not found, installationinstructions are locatedhere. For a Mac, the installation instructions are locatedhere.               Yarn. Install instructions for yarn can be foundhere.  For theMac, see the node link above.          The guidelines from the Scratch team say to use npm, but I’ve foundthat npm does not seem to work in the Scratch environment. Also,with yarn, you do not need to worry about when and where to invokesudo.        A copy of updated versions of scratch-vm and scratch-gui.          Download the s3onegpio distribution by clicking on the greenDownload button and unzip into any directory you choose.      For Windows, do this in WSL.        Please note, both this extension and Scratch 3 are subject to codechanges, so please be prepared for a bumpy ride. Hopefully, there willbe limited churn. The s3onegpio distribution will most likely bechanging over time, so at a minimum, it will need to be updated as Iadd features and fix bugs. Building The Code The instructions for building the code are taken directly from Hiro’sarticle. You do not need to git clone the code, you have already donethat by downloading and unzipping. You need to:   Go to the scratch-vm directory and enter:    yarn install        and then     yarn link        Go to the scratch-gui directory and enter:    yarn link scratch-vm        and then     yarn install        Next, within the scratch-gui directory, start the code by entering:    yarn start        You will most likely see a lot of warning messages. You can ignorethose. The start takes a few moments, and you should wait for a messagethat states, “Compiled Successfully.”     Finally, open your Web browser tohttp://0.0.0.0:8601. Scratch 3 should open. Ifyou click on the + “add extension button” at the bottom left ofScratch, the very last extension shown should be OneGPIO. If youclick on that selection, the single “Connect To” block should appear.If you click on the drop-down, you will see a selector for the 3board types supported. But Does It Work? If you click on the Connect To block, you will see an alert tellingyou that the WebSocket Connection Closed. That is because we first needto start a WebSocket server, which is precisely what the BanyanWebSocket Gatewayis. Starting The Python Banyan WebSocket Gateway Before starting the WebSocket Gateway, Python Banyan needs to beinstalled.This posthas a quick explanation of what Python Banyan is and how to install it.For Windows, you will need to install using a standard Windows Commandwindow, since WSL does not support networking, required by PythonBanyan. You do not need to get into the details of Python Banyan unless you wishto. To start the WebSocket Gateway, in a Windows Command window or Linuxor Mac terminal window, go to theonegpio directoryin your downloaded distribution of s3onegpio. Next, type the followingcommand: bls -f a.csvThis command instructs the Banyan Launch Server (bls) to start up allthe necessary Banyan components we need. If you now go back to the Web browser and press the F12 key to open theconsole and click on the Connect To block, you should see something likethis in the console: connect index.js:49Object { mutation: undefined, TEXT: \"1\" }index.js:50{\"id\":\"to_arduino_gateway\"} index.js:73This output indicates a successful connection to the WebSocket Servier.If you then kill the WebSocket Gateway, you will see a Web alert messagetelling you that the connection has closed. So now we conclude today’s post. In summary, we installed the code tobuild the s3onegpio Scratch extension, built and started the code,opened a Web browser to run Scratch with the new extension, invoked thePython Banyan WebSocket Gateway and connected to it using the Scratchconnect block. What a great start! In The Next Post The goal for the next posting is to create additional Scratch blocks toset a digital pin to output mode, and to control the pin using bothdigital and PWM output. Wish me luck ;-). ","categories": ["scratch3","gpio"],
        "tags": [],
        "url": "http://localhost:4000/bots-in-pieces/scratch3/gpio/2019/09/15/scratch3-1.html"
      },{
        "title": "Creating a Scratch3 Extension For GPIO Control - Part 2",
        "excerpt":"Success! We Are A Blinkin’ And A Fadin’ - Just A Quick Update Here is the very first Scratch 3 OneGPIO Script In this post, we are not going to get into much detail, but I just wanted to share the success. Here is a short video demo of the Scratch 3 OneGPIO Extension.  The script is controlling 2 LEDs on anArduino CodeShield. Click the photo tosee it in action. Here is a screenshot of the full complement of OneGPIO Extension blocks. The script was also modified slightly to select a Raspberry Pi and thepin numbers were changed to control the LEDs on aPibrella. Again, it wassuccessful!  When the code for all the blocks has been implemented and tested, thecode and instructions for its use will be made available. Until next time! ","categories": ["scratch3","gpio"],
        "tags": [],
        "url": "http://localhost:4000/bots-in-pieces/scratch3/gpio/2019/09/16/scratch3-2.html"
      },{
        "title": "Creating a Scratch3 Extension For GPIO Control - Part 3",
        "excerpt":"Moving Forward  This is going to be another short posting, allowing me to devote moretime to develop, test, and document the OneGPIO Scratch 3 extensions. Progress since the last posting:   Extension support for Arduino, ESP-8266, and Raspberry Pi has beenbroken out into three separate extensions allowing for:          The ability for multiple OneGPIO extensions to be active at a time.      The ability to remotely control a Raspberry Pi from a Windows, Mac, or Linux  computer.        The Scratch blocks were refactored for ease of use.          The Connect block was removed, and connecting to the extensionservers is now handled automatically without explicit userinteraction.      Setting GPIO pin modes, such as input, output, and PWM is nowhandled automatically within the command and reporter blocks.      Block text was changed but is not yet finalized.        Cursory testing of the Arduino, ESP-8266, and Raspberry Pi extensionsis complete.A Separate Extension For Each Board Type Each board type now has an extension of its own, and all areaccessible from the web in asingle Scratch 3 editor.   Note that these are “unofficial” Scratch 3 extensions. The link aboveis not part of the official Scratch 3 release, but are built from thelatest versions of the Scratch 3 source code provided by the ScratchTeam. Note also that the servers that connect an extension to itsassociated hardware have not yet been released. The servers are fullyfunctional, but they are being refactored to make them moreuser-friendly for easy start-up. They should be available for use bythe time the next posting is published. One of the advantages of having separate extensions is that more thanone board can be supported at a time. You can then create a Scratchscript that uses input data from one board to affect the devices onanother. For example, and this has been tested, one can monitor a pushbutton switch connected to an Arduino, and when the button is pushed, anLED on a Raspberry Pi lights up. Release the switch, and the LEDextinguishes. For the Raspberry Pi, one has the option to control its GPIO pins eitherby running Scratch 3 directly on the Raspberry Pi or running Scratch 3remotely on a Windows, Mac, or Linux computer. Refactored Scratch Blocks The Scratch blocks were refactored to be simpler to use. Pin modes areset automatically when any of the blocks are executed. The Connectblock was removed, and connection to the board specific servers is nowperformed automatically. Block text was modified but has not been finalized. The Arduino Blocks  The ESP-8266 Blocks  The Raspberry Pi Blocks  Testing All three supported boards, the Arduino Uno, ESP-8266, and Raspberry Pihave been tested, but have not been stressed. All blocks worked with allboards as expected. Upcoming Goals   Completion of the board-specific connection servers.  Provide on-line documentation for installation, use, and theory ofoperation for the OneGPIO extensions.  Investigate providing integrated block text translations.","categories": ["scratch3","gpio"],
        "tags": [],
        "url": "http://localhost:4000/bots-in-pieces/scratch3/gpio/2019/10/03/scratch3-3.html"
      },{
        "title": "Creating a Scratch3 Extension For GPIO Control - Part 4",
        "excerpt":"Release 1.0 Is Now Available  Release 1.0 was released earlier today, and an onlineUser’s Guide is now available. With this release, you can:   Control a Raspberry Pi locally or remotely from your PC.  Control multiple boards simultaneously and have the controllersinteract with one another.  Language translation for the Scratch blocks is available. CurrentlyEnglish, Brazilian Portuguese and Portuguese is offered. If you wouldlike to contribute a translation, the User’s Guide explains how.Try it out, and let me know what you think! ","categories": ["scratch3","gpio"],
        "tags": [],
        "url": "http://localhost:4000/bots-in-pieces/scratch3/gpio/2019/10/17/scratch-3-4.html"
      },{
        "title": "Scratch 3 Extensions - Part 5",
        "excerpt":" With the publication of Scratch 3 hardware extensions  for the Picoboard andCircuit Playground Express, the s3oneGpio Scratch 3 extensions project has come to a close (well,for a while at least). The New Extension Blocks The Picoboard Blocks  The Circuit Playground Express (CPX) Blocks  Pymata-cpx In addition to the Scratch 3 extensions, a Python API library was developedto help support the CPX Scratch extension. This API provides a simple to use Python interfacefor users who wish to reach beyond Scratch programming and to try physical computing withuser-friendly hardware. What’s Next I have been playing with Arcade and have been experimenting withintegrating Python Banyan with Arcade. The goal is to create a multi-player gamethat may be distributed across computers.Each player would play the game on their individual computersand connected via Banyan across a LAN. Stay tuned for any progress. ","categories": ["scratch3","picoboard","circuit-playground-express"],
        "tags": [],
        "url": "http://localhost:4000/bots-in-pieces/scratch3/picoboard/circuit-playground-express/2020/02/02/scratch3-5.html"
      },{
        "title": "Peer To Peer Gaming With Arcade and Python Banyan - A Proof Of Concept",
        "excerpt":" I recently read a RealPython article about Paul Craven’s Arcade gaming library for Python.After examining  the Arcade examples,I was impressed by Arcade’s consistency and ease of use.   Want to quickly get up to speed with Arcade? Check out this12 part YouTube Arcade tutorial. The Arcade library was designed to create 2D games to be run on a single computer, and it accomplishesthat goal brilliantly. That being said, having run an after-school Scratch club for a local middle school, one of the things mystudents always wished for was the ability to create multi-player networked games. Sadly, Scratch does not support this, and the students were left disappointed. Thinking of my students, I decided to see if I could use Arcade to createmulti-player games. And thus, this multi-player proof of concept began. In this posting, I will discuss how to create a multi-player game usingthe Python Arcade gaming library in conjunction with the Python Banyan framework.Banyan augments Arcade by providing the networking and messaging support required formulti-player games. What will be covered:   A short discussion of multi-player software architectures.  The self-imposed requirements and goals of the proof-of-concept presented in this posting.  How I selected a game to demonstrate the concepts.  How to install and run the demo code.  Getting into the details:          A quick introduction to Python Banyan.      Looking at how the code was assembled.      Multiplayer Support Schemes - Client/Server vs. Peer To Peer Multiplayer games generally are implemented using one of 2 schemes, client/server being one, and peer to peer(p2p)being the other.  With the client/server model, the players connect to a central server. The server receives the individual player’sinteraction events (keyboard presses, mouse moves, joystick motion, etc.), updates the game basedon the events received, and then generates and sendsscreen updates to the individual players. Pros   Relatively easy to implement.  Cheating is averted since the server monitors all eventsCons   It requires a separate server or server process. With peer to peer (p2p), there is no central server. As each player generates screen events, the local game instancesends screen update requests to each of the players. Pros   No central server required. Players communicate directly with each other.Cons   More difficult to implement than the client/server model.  Potential for game cheating since no central authority is in control.Goals and Requirements Of The Project Taking the road less traveled, I decided to explore using the p2p model. Hereare the requirements I set for myself:   The game is intended to be confined to a single LAN. Restricting support to within a single LAN avoids security issues and simplifies routing.  The game is to consist of a single Python script run as two separate processes on a single computer, oron two different computers.  Player role selection is accomplished using a command-line option.  Linux, macOS, and Windows are to be supported.  As each player generates game events, screen updates must be fast and in sync with the other player.  Compatible with Python 3.7 and above.The Proof Of Concept Finding A Game Candidate Realizing that I am not the best at designing computer games, I wanted to find an existing gamethat I could modify to illustrate my proof of concept ideas. Turning to the Arcade examples, I chosetheCollect Coins that are Bouncing example But Isn’t That A One-Player Game?  When first looking at the game, it appears that there is only one player. The goal of the game isfor the player, using the mouse, to collect all of the randomly bouncing coins. When the female sprite touches a coin, the coin is removed from play, and the score is incremented by 1. This looks like a single-player game, but what if we viewed the game in a slightly different way. What if the female sprite, which wecall player 1, was controlled on one computer, and the coins and their random motion on another computer.We can then consider the coins as player 0. In this way, we have a two-player game with one player, player 1 being human-controlled, and the other player, player 0, being computer-controlled. Each of the players would need to have a copy of the mouse-controlled player sprite, the 50 coin sprites,and game score text. Each player is responsible for updating their own domain and notifying the peer of theseupdates. Both player’s screens need to be updated in unison in near real-time! A Video Demo Of The P2P Game Before learning how all this works, it may be beneficial to see an actual demo of the proof of concept. The demo was run on a Linux computer with an AMD 3700x processor for one of the peers,and on a Windows 10 laptop using an Intel i7-6600q processor for the second peer. Both computersare running RealVNC to allow for screen-capture of both machines. The left-hand side of the screen is the Linux computer, and it controls the coins. Theright-hand side is the Windows computer, and it controls the female collection sprite. NOTE: Swapping the players on the computers does not affect performance. What You Will See When each instance of the game starts, it generates its own copy of the female collection spriteand the 50 coin sprites. The collection sprite is initially placed at the same screen location forboth players. The coins for each player, are initially placed randomly on each screen. Therefore at this time, the coin placements differ for each of the players. This is shown below.  When the left mouse button is clicked, the coins will go into motion. Notice thatonce that happens, the positions of the coins are aligned on both screens. After the right mouse button is clicked to enable coin collection when the female sprite touches a coin sprite, thecoin is removed, and the score is increased by one. To view a screen capture of the demo, click on the screen-shot below.  Running The Demo For Yourself Install The Demo To install the code, open a terminal window. For Linux and macOS type: sudo pip3 install p2p-arcadeFor Windows type: pip install p2p-arcadeIn addition to all the necessary libraries, a command-line executable, p2pa is installed. If you wish to run the demo using two computers, repeat the steps above on the second computer.   IMPORTANT NOTE: Arcade does not run on a Raspberry Pi because it requires OpenGL 3.3, whichis not yet available for the RPi. Running The Demo On One Computer If you wish to try the demo on a single computer, open a terminal window and type: p2paThis will start the player 0 window. Next, open another window, but this time type: p2pa -p 1The -p command-line option specifies that this instance is to be run as player 1. Now click the left mouse button to start the coins in motion and then click the right mouse button and collect the coins. Running The Demo On Two Computers On the first computer, open a terminal window and type: p2paIn the terminal window you will see a Python Banyan informational heading that looks similar to that below: ************************************************************Arcade p2p player0 using Back Plane IP address: 192.168.2.191Subscriber Port = 43125Publisher  Port = 43124Loop Time = 0.0001 seconds************************************************************The value for the IP address of your computer will most likely be differentthan the one shown above, so jot down the Back Plane IP address displayed. Now on the second computer, open a terminal window type in a command similar to the following,substituting the IP address you jotted down. p2pa -p 1 -b 192.168.2.191The -p command-line option specifies this instance as a player 1 instance, and the -b option specifies the IP address of the active Banyan Backplane. The Banyan Backplane routes all of the messages for you without having to set upany routing tables.   When you started player 0 on the first computer, the Backplane was automatically invoked. The -b command-line option is used to connect both peers to a common Backplane. Click the left mouse button, followed by a click of the right mouse button to start collecting coins. So How Does This All Work? While reading this section, if you wish to view the source code for the original game example, click on this link.To view the source code for p2p-arcade.pyclick here. Defining And Implementing Game Behavior In Arcade If you’ve read the RealPython article and/or have watched the videos, you already know that the arcade.Window class provides several methods to capture hardware events, such as mouse orkeyboard interaction.     def on_mouse_motion(self, x, y, dx, dy):        \"\"\" Handle Mouse Motion \"\"\"        # Move the center of the player sprite to match the mouse x, y        self.player_sprite.center_x = x        self.player_sprite.center_y = yThe arcade.Window class also has an on_update method allowing you to control screen updates with each iteration of the event-loop. This is shown below.    def on_update(self, delta_time):        \"\"\" Movement and game logic \"\"\"        # Call update on all sprites (The sprites don't do much in this        # example though.)        self.all_sprites_list.update()        # Generate a list of all sprites that collided with the player.        hit_list = arcade.check_for_collision_with_list(self.player_sprite,                                                        self.coin_list)        # Loop through each colliding sprite, remove it, and add to the score.        for coin in hit_list:            coin.remove_from_sprite_lists()            self.score += 1The on_update method calls the  update method within the all_sprites_list. The all_sprites_list iterates through its list of spritescalling each sprite’s update method. class Coin(arcade.Sprite):    def __init__(self, filename, sprite_scaling):        super().__init__(filename, sprite_scaling)        self.change_x = 0        self.change_y = 0    def update(self):        # Move the coin        self.center_x += self.change_x        self.center_y += self.change_y        # If we are out-of-bounds, then 'bounce'        if self.left &lt; 0:            self.change_x *= -1        if self.right &gt; SCREEN_WIDTH:            self.change_x *= -1        if self.bottom &lt; 0:            self.change_y *= -1        if self.top &gt; SCREEN_HEIGHT:            self.change_y *= -1Hopefully, I did not lose you with the discussion of nested-updates. But in case I did,here is a diagram to illustrate update sequencing.  Adding Multiplayer Functionality To implement a multi-player game, we need a way for each player tocapture both hardware events and screen update information. Each player then must notify its peer of these changes. To provide a vehicle for player update notifications, we will be using the Python Banyan Framework. Understanding The Modified Code So to understand the p2p_arcade.py code, we will:   Discuss the basics of Python Banyan  Show how the MyGame class is extended to incorporate Python Banyan and the Python threading class.          Threading is used to provide concurrency between the Arcade and Banyan event loops.        Explain how the data is captured.  Show how the captured data is sent, received, and processed by both players.What Is Python Banyan? The Python Banyan Framework is a lightweight, reactive framework used to create flexible, non-blocking, event-driven, asynchronous applications. Quite a mouthful,but it very easy to use and has a straightforward API. Banyan uses a publish/subscribe (pub/sub) messaging model. We will discuss pub/sub in  more detail in the sections that follow. For Those Familiar With MQTT Pub/Sub Python Banyan, in some ways, is similar to MQTT but has much better performance. Similar to MQTT’s broker, Python Banyan uses an entity called the Backplane. For the p2p_arcadedemo, the Backplane is automatically started for you. Banyan Components Banyan entities, known as Banyan Components, communicate with each other by connecting to a common Banyan Backplane. The Backplane is a central point of contact for all theBanyan Components. It simplifies message routing in that all Banyan Components use  sharedIP Addresses and IP ports for publishing and subscribing to messages. A Banyan Component is an independent process but is a member of a set of Components that comprise a Banyan Application. Banyan Applications The player 0 instance of p2pa runs as one Banyan Component, and theplayer 1 instance of p2pa is run as a second Banyan Component. Together, both components createa single Banyan Application communicating with one another using LAN connected messaging. If the Banyan Components reside on a single computer, they will all automatically connectto the local Backplane. If the Banyan Application is distributed acrossmultiple computers, both Banyan Components still need to share a single Backplane. Banyan Distributed Applications Banyan Components may be distributed across multiple computers withoutany code changes.The only difference between a distributed and non-distributed Banyan Application is thatwe need to point one or both of the Banyan Components to a common Banyan Backplane. If you recall, when running the p2pa demo across two machines, the -b command-line optionto connect player 1 to connect to the same Backplane that player 0 was using. Pub/Sub  Publishing A Message With the pub/sub model, a publishing entity gathers data, forms a message containing the data, and thenpublishes the message to the network. In addition to the data, each message is associated with a message topicat the time of the publication. Messages are created as a Python dictionary. So, for example, let’s say we wish to publish a messagecontaining the current time containing hours, minutes, and seconds. Here is one way of doing this. To get the current time, we first need to import datetime, then we call datetime.datetime.now() toretrieve the current time. import datetimenow = datetime.datetime.now()Using the results in now, let’s build a Banyan message. payload = {'hour' = now.hour, 'minute' = now.minute, 'seconds' = now.seconds}To publish the message we need to call the Banyan method publish_payload. The publish_payload method takes two parameters. The first is the payload, and the second is a message topic.For this example, we will set the topic to ‘current_time’. self.publish_payload(payload, 'current_time')Python Banyan automatically encodes the message for transmission and takes care of all the TCP/IP detailsfor you. Subscribing To Receive Messages A subscribing entity may elect to receive all messages for one or several topics of interest. Continuing with our example,to receive messages with the ‘current_time’ topic, we need to subscribe to the ‘current_time’ topic. To set a subscription topic,the set_subscriber_topic method is called, passing in the topic string. self.set_subscriber_topic('current_time')A separate call to set_subcriber_topic is used for each topic of interest. Next, we need to start the Banyan receive-loop. The receive_loop waits to receiveany messages with topics that match the topics we have elected to receive. self.receive_loop()Because the receive_loop must run continuously without blocking, it will be runin a separate thread from the Arcade event-loop. Processing Incoming Messages When the Banyan receive_loop receives a message, it automatically calls a Banyan method called incoming_message_processing(). This method must be overridden for the message to be processed. When Banyan calls incoming_message_processing, it passes in two parameters. The first is the message topic string, and the second is the decoded message payload. We can use the message topic to de-reference messages from one another. We canthen do whatever we need to properly process the message. Extending And Modifying MyGame For Multi-Player Functionality To add Python Banyan behaviors as well as multi-threading behaviors to the MyGame class, we redefine it as: class MyGame(arcade.Window, threading.Thread, BanyanBase):As with single inheritance, we need to initialize all of the parentclasses by calling the __init__ method for each of the parent classes. arcade.Window.__init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, title)threading.Thread.__init__(self)BanyanBase.__init__(self, back_plane_ip_address=back_plane_ip_address,                    process_name=process_name, loop_time=.0001)        # Initialize the python-banyan base class parent.        #        # If the backplane_ip_address is == None, then the local IP        # address is used.        #        # The process name is just informational for the Banyan header        # printed on the console.        #        # The loop_time the amount of idle time in seconds for the        # banyan receive_loop to wait to check for the next message        # available in its queue.The Modifying The Coin Class For the Coin class, we add an attribute, my_index, and provide getter and setter properties for theattribute. We also remove the original code contained in the update method. class Coin(arcade.Sprite):    \"\"\"    Coin sprite definition    \"\"\"    def __init__(self, filename, sprite_scaling):        super().__init__(filename, sprite_scaling)        self.change_x = 0        self.change_y = 0        # Assign an index number to each coin        # so that we can track coins across game instances.        # We establish this as a property in the methods below.        self._my_index = None    @property    def my_index(self):        return self._my_index    @my_index.setter    def my_index(self, index):        self._my_index = index    def update(self):        \"\"\"        Updates will be controlled in the second thread        using python-banyan.        \"\"\"        returnWhy do we need my_index? Each player is a process running in its own memory space. Each player process has its own copy ofthe coin_list. When we need to remove a coin from the list forboth players, we need a memory independent way of identifying which coin to remove. Coins with matchingmy_index values represent coins having the same positions on both screens. By using the my_index value to identifya specific coin to remove, both screens will appear to remove the same coin. Continuing With Modifications To The MyGame Class Modifications To setup    def setup(self):        \"\"\"        Initialize the game        \"\"\"        # Sprite lists        self.all_sprites_list = arcade.SpriteList()        self.coin_list = arcade.SpriteList()        # Set up the player 1        # Character image from kenney.nl        self.player_sprite = arcade.Sprite(\":resources:images/animated_characters/female_person/femalePerson_idle.png\",                                           SPRITE_SCALING_PLAYER)        self.player_sprite.center_x = 50        self.player_sprite.center_y = 50        self.all_sprites_list.append(self.player_sprite)        # Create the coins which constitute player 2        for i in range(COIN_COUNT):            # Create the coin instance            # Coin image from kenney.nl            coin = Coin(\":resources:images/items/coinGold.png\", SPRITE_SCALING_COIN)            # Position the coin            coin.center_x = random.randrange(SCREEN_WIDTH)            coin.center_y = random.randrange(SCREEN_HEIGHT)            coin.change_x = random.randrange(-3, 4)            coin.change_y = random.randrange(-3, 4)                        # add the index number to each coin            coin.my_index = i            # Add the coin to the lists            self.all_sprites_list.append(coin)            self.coin_list.append(coin)When creating the coins, we set each coin’s my_index value. Also, we moved score initializationfrom the __init__ method to here. Modifications To on_mouse_motion     def on_mouse_motion(self, x, y, dx, dy):        \"\"\"        Mouse motion detection and handling        :param x: x position        :param y: y position        :param dx: change in x        :param dy: change in y        \"\"\"        # Move the center of the player sprite to match the mouse x, y        # by publishing the position as a banyan message.        if self.player == 1:            payload = {'p1_x': x, 'p1_y': y}            topic = 'p1_move'            self.publish_payload(payload, topic)Here we remove updating the position of the female sprite directly. Player 1 captures the current x and ypositions of the mouse, assembles a Banyan message containing those values, and then publishes the messagewith a topic of ‘p1_move’ to indicate player 1 moved on the screen. Both players will update the player position on their respective screens when the message is received andprocessed. This will be discussed a little further down. Adding Code To Process Mouse Button Presses     def on_mouse_press(self, x, y, button, modifiers):        # start the coins in motion        if button == arcade.MOUSE_BUTTON_LEFT:            payload = {'go': True}            self.publish_payload(payload, 'enable_coins')        # start collision detection if we've started the coins in motion        if self.go:            if button == arcade.MOUSE_BUTTON_RIGHT:                # self.run_collision_detection = True                payload = {'collision': True}                self.publish_payload(payload, 'enable_collisions')Here we detect left or right mouse button presses. An appropriate Banyanmessage is assembled for each press type and published. When the enable_coins messageis received in the Banyan receive_loop thread, the go attribute is set to True, enablingcoin motion. When the enable_collisions message is received in the Banyan receive_loop, the run_collision_detectionis set to True, enabling collision detection. Modifying arcade.Window.on_update     def on_update(self, delta_time):        \"\"\"        Update the sprites.        :param delta_time:        \"\"\"        # update the female collection sprite.        self.all_sprites_list.update()        # If we started the coins in motion, and this is the \"coin\" player,        # gather all the current positions of the coins in the coin_list.        if self.go:            if self.player == 0:                # build a list of all the coin positions using a list comprehension.                # publish this list with the updated coin positions.                with self.the_lock:                    coin_updates = [[self.coin_list.sprite_list[i].center_x,                                     self.coin_list.sprite_list[i].center_y] for i in range(len(self.coin_list))]                    payload = {'updates': coin_updates}                    self.publish_payload(payload, 'update_coins')Here, we removed the check for sprite collision detection and the code to increase the score. We added code to check if the sprites are currently in motion using the go attribute. Then player 0, the computer-controlled coins player, builds an array of all of the remaining coins’ center x and y positionsand then publishes that information using the update_coins topic string. The data is gathered using a list comprehension for speed and clarity. Because both the arcade event-loop andBanyan event-loop require access to the coin_list, we want to make sure that only one thread at a timehas access to the coin_list.This ensures the data integrity of the coin_list for both threads. The Banyan Thread Starting The Thread     # Process banyan subscribed messages    def run(self):        \"\"\"        This thread continually attempts to receive        incoming Banyan messages. If a message is received,        incoming_message_processing is called to handle        the message.        \"\"\"        # start the banyan loop - incoming messages will be processed        # by incoming_message_processing in this thread.        self.receive_loop()When the Banyan thread begins, it starts the Banyan receive_loop. The receive_loopinternally runs forever, and therefore this thread will stay alive for the lifetimeof the program Processing Incoming Banyan Message     def incoming_message_processing(self, topic, payload):        \"\"\"        Process the incoming Banyan messages        :param topic: Message Topic string.        :param payload: Message Data.        \"\"\"        if self.external_message_processor:            self.external_message_processor(topic, payload)        else:            # update the coins positions            if topic == 'update_coins':                # get the new coordinates                the_coordinates = payload['updates']                # update the coin positions with the new coordinates                with self.the_lock:                    for i in range(len(the_coordinates)):                        try:                            self.coin_list.sprite_list[i].center_x = the_coordinates[i][0] \\                                + self.coin_list.sprite_list[i].change_x                            self.coin_list.sprite_list[i].center_y = the_coordinates[i][1] \\                                + self.coin_list.sprite_list[i].change_y                            # If we are out-of-bounds, then 'bounce'                            if self.coin_list.sprite_list[i].left &lt; 0:                                self.coin_list.sprite_list[i].change_x *= -1                            if self.coin_list.sprite_list[i].right &gt; SCREEN_WIDTH:                                self.coin_list.sprite_list[i].change_x *= -1                            if self.coin_list.sprite_list[i].bottom &lt; 0:                                self.coin_list.sprite_list[i].change_y *= -1                            if self.coin_list.sprite_list[i].top &gt; SCREEN_HEIGHT:                                self.coin_list.sprite_list[i].change_y *= -1                        # this should not happen, but if it does,                        # just ignore and go along our merry way.                        except (TypeError, IndexError):                            continue                # perform hit detection if enabled with the right mouse button.                with self.the_lock:                    if self.run_collision_detection:                        hit_list = arcade.check_for_collision_with_list(self.player_sprite,                                                                        self.coin_list)                        # hit detected                        if hit_list:                            for coin in hit_list:                                # publish a remove_coin message using the coin                                # index as the payload. The index is necessary                                # so that we can remove coins for both players.                                coin_index = coin.my_index                                payload = {'coin': coin_index}                                self.publish_payload(payload, 'remove_coin')                                # allow time for the message to be published cleanly                                time.sleep(.0001)            # move player `1` on the screen            elif topic == 'p1_move':                self.player_sprite.center_x = payload['p1_x']                self.player_sprite.center_y = payload['p1_y']            # now actually remove the coin identified in hit detection            # by using its index.            elif topic == 'remove_coin':                with self.the_lock:                    coin_index = payload['coin']                    for coin in self.coin_list.sprite_list:                        if coin_index == coin.my_index:                            coin.remove_from_sprite_lists()                            self.score += 1            elif topic == 'enable_coins':                self.go = True            elif topic == 'enable_collisions':                self.run_collision_detection = TrueThe incoming_message_processing method is called by the receive_loop when an incomingmessage arrives. Each message is processed in accordance with its topic string. The ‘update_coins’ message updates each coin’s screen position. This code was originally in the Coin class update method. In addition, it duplicates the original ‘bounce logic’ as well. Sprite collision is performed hereso that coins can be removed from the coin list, and the score increased when a collision is detected. The ‘p1_move’ message updates the collection sprite’s position on the screen. The enable_coins and enable_collisions messages set their respective flags to enable game functionality.   NOTE: Both player 0 and player 1 receive and process these messages. However, the generationof these messages in the Arcade event-loop thread is typically generated by only one player. Concluding Comments We have seen that Arcade can be enhanced to become a multi-player p2p game engine withthe use of Python Banyan and the Python threading library. There were no changes made to theArcade library nor to the Python Banyan Framework. Now it’s up to you to try your hand at creating a multi-player p2p game! ","categories": ["python-Banyan","arcade"],
        "tags": ["gaming","p2p"],
        "url": "http://localhost:4000/bots-in-pieces/python-banyan/arcade/2020/02/21/p2p-arcade-1.html"
      },{
        "title": "Pymata4",
        "excerpt":"Pymata4 Released! Pymata4 is the latest in a series of Python clients I’ve developed over the years  for Arduino microcontrollers. Here is a list of its major features:   Python 3.7 (or higher) compatible.  It offers a simplified API.  Uses conventional concurrency techniques (threading) for high efficiency.  It Is FirmataExpress compatible (link speed runs at 115200)  Data change events may be associated with a callback function for asynchronous notification, or polling may be used when a synchronous approach is desired.  Each data change event is time-stamped and stored.  A full set of working examples are available for download online.Pymata4 Replaces PyMata and pymata-aio Both the original PyMata library, as well as the pymata-aio library, have been archived. Use Pymata4 for conventional Python programming, and for asyncio projects, choose pymata-express. ","categories": ["pymata","arduino"],
        "tags": ["gaming","p2p"],
        "url": "http://localhost:4000/bots-in-pieces/pymata/arduino/2020/03/29/pymata4.html"
      },{
        "title": "Pymata-Express Updated",
        "excerpt":"Pymata-Express Version 1.11 Released! An update of Pymata-Expresshas been released. The API has been updated to be consistent with thepymata4 API. The format for the data reported in callbacks has been updatedas follows:             Callback      Prior To Version 1.11      Version 1.11 And Above                         analog input      [pin, current reported value, pin_mode, timestamp]      [pin_mode = 2, pin, current reported value, pin_mode, timestamp]                     digital input      [pin, current reported value, pin_mode, timestamp]      [pin_mode = 0, pin, current reported value, pin_mode, timestamp]                     hc-sr04      [pin, distance]      [pin_mode=12, trigger pin number, distance, timestamp]                     i2c      [Device address, data bytes]      [pin_mode=6, i2c device address, data bytes, timestamp]             No other API changes were implemented. The User’s Guide has been updated and improved. Here is a list of its major features:   Python 3.7 (or higher) compatible.  It offers a simplified pure asyncio API.  Uses asyncio concurrency techniques for high efficiency.  It Is FirmataExpress compatible (link speed runs at 115200)  Data change events may be associated with a callback function for asynchronous notification, or polling may be used when a synchronous approach is desired.  Each data change event is time-stamped and stored.  A full set of working examples are available for download online.","categories": ["pymata","arduino"],
        "tags": ["gaming","p2p"],
        "url": "http://localhost:4000/bots-in-pieces/pymata/arduino/2020/04/05/pymata-express.html"
      },{
        "title": "Creating GUIs With Page",
        "excerpt":"Back After A Hiatus Once again, I have not been able to post regularly. Thankfully,I am well, and I hope the same is true for you and yours. My excuse this time is that “I’ve been busy.” I’ve been working on a new Pymata client called pymata4 and a Firmata based client for the RoboHAT MM1and a Scratch extension for the RoboHAT board. Lately, I have been working on GUI for the RoboHAT and thought I would share my discovery of a great GUI building tool. Some Thoughts About Creating GUIs As a programmer, after crafting and then completing an interactive GUI, there is no better feeling than sitting back, admiring my visual masterpiece, and thinking to myself, “Job well done.”  And then I think, “Man, was that ever painful.” Let’s face it, GUI programming is often tedious and time-consuming. No matter which GUI library you pick, getting the visual aspects “just right” can be an infuriating experience. Coding up the logic that interacts with the GUI widgets is usually quick and straightforward, but not so for getting those pesky widgets looking “just right.” To aid in getting those visual aesthetics correct, modern GUI libraries include geometry managers to assist in laying out the widgets on the screen. The Python tkinter library includes 3 such geometry managers, namely, the place, pack, and grid managers. ZetCode describes these follows: “The place geometry manager positions widgets using absolute positioning. The pack geometry manager organizes widgets in horizontal and vertical boxes. The grid geometry manager places widgets in a two-dimensional grid. “ Why am I discussing tkinter when there is so much else to choose from? The answers are relatively simple – it is already bundled with Python, and I have used it in the past. When reading tutorials on creating GUIs, you are usually strongly discouraged from using the place geometry manager since it requires you to know the absolute x and y coordinates for each GUI widget on the screen. Both the pack and grid managers use algorithms built into their code to perform screen placement. Essentially, you just instantiate a GUI widget, associate it with the manager, and you are done. Auto-magically, things are placed correctly for you. No-fuss, no muss. Well, that’s the theory. In reality, the correct placement is close, but to get things to look like you may wish,  a lot of “minor” tweaking is required to get everything to look “just right.” When I go to create a GUI, I usually use the grid manager to do my placement and then spend the next several weeks doing the tweaking. I don’t know about you, but I would rather be coding than tweaking. For me, this is not time well spent. For my latest GUI endeavor, I wanted to see if a WYSIWYG (What You See Is What You Get) design tool exists for tkinter. With WYSIWIG, you drag and place the widgets visually on the screen, thereby saving some time and frustration.The tool then generates the code that instantiates and positions the widgets on the screen. The tool should also have the ability to  create the stubs for the GUI events. If I could find such a tool, I thought the entire GUI experience might be enjoyable and not just at its completion. The good news is, I found such a tool, and its name is Page. The bad news, well, there is no bad news. Page uses the place layout manager, so what you see is truly what you get, without having to go back and tweak things. Before getting into a discussion about Page, let me point out that you still need to understand tkinter programming. There is no getting around that. I have used “Modern Tkinter For Busy Programmers”  as a learning guide that clearly and succinctly gets to the point.   There is also a free online version if you prefer.  In the screenshot above, you can see Page ready to start a new project. Page displays its main menu, a Widget Toolbar, where you select the widget you wish to use. A Toplevel window, where you place the widgets, an Attribute editor will enable you to quickly modify the widget’s attributes and a Widget Tree that allows you to quickly find a widget you’ve added to the project. I am not going to spend much time here explaining the details of how to use Page. The Page documentation is extensive and does that very well. Instead, let me show what I accomplished in under an hour with Page.  Subsequently, I finished laying out all the tabs for the GUI in under 4 hours! The purpose of this GUI is to control the GPIO pins and the RoboHAT MM1 controller’s various devices. The screenshot above is that of the first tab of that GUI. This screen allows a user to select a digital output pin mode for all eight RoboHAT “Servo” pins. Once a pin mode is selected, the user may set the pin’s output value by using the slider widget. Because Page has a cut and paste feature, it was trivial to recreate all of the widgets for all 8 pins. After laying out all the widgets, all of the tkinter code, including the event stubs, was created with just 2 clicks of the mouse. Page has another really nice feature. It separates out the GUI generation code from that of the event stubs. That means you can independently update the GUI and only generate new stub code when you need to. It will even merge the new stub code with the existing code so that you don’t lose your changes. If you are interested in creating a tkinter GUI for your project, you should seriously consider using Page. The author, Don Rozenberg, supports this project, and IMHO goes above and beyond what most open source developers do. One last thing - make sure that you install ActiveState ActiveTcl as recommended in Page’s documentation. Initially, I didn’t, and it caused some issues when using Linux. ","categories": ["GUI","tkinter","pymata-rh"],
        "tags": ["GUI"],
        "url": "http://localhost:4000/bots-in-pieces/gui/tkinter/pymata-rh/2020/08/23/using-stage.html"
      },{
        "title": "Introducing The Telemetrix Project",
        "excerpt":"So, What Is Telemetrix? Telemetrix is a play on the word “telemetry.” Telemetry collects data at remote points and automatically transmits the data to receiving equipment (telecommunication) for monitoring. The telemetrix package consists of 2 majorcomponents, the Python client and the Arduino server. If this sounds like a description of Firmata, it is no small coincidence. The telemetrix project intends to replace Arduino Firmata with a more straightforward protocol and an eye toward allowing feature extensibility in a simple manner. And, Why Telemetrix? Creating a replacement for Firmata might seem strange from someone who has spent the better part of the last seven years creating both Python Firmata clients (pymata, pymata-aio, pymata4 pymata-express) and two extended versions of StandardFirmata (FirmataPlus and FirmataExpress). What convinced me to develop telemetrix is this issue reported against pymata4.  The issue is specific to STM32 processor boards and has to do with analog input pins number designations being incorrectly mapped to their physical pins. If you read the issue, you will see my trials and tribulations trying to get an  STM32 up and running. After finding a board that I could program, I could not  establish serial communication between any pymata client and StandardFirmata.  However, I created a simple native Arduino sketch that allowed me to send a  character with the Arduino serial monitor and have it looped back, so I knew the board,  and serial communication worked. What was the cause of Firmata’s inability to communicate over the serial link for this STM32 board? This problem is challenging to debug since the only  simple debug tool for Firmata is sending informational debug packets across the serial link.  However, since there was no communication, to begin with,  hunting down the exact cause would be a slow and painful process. Instead, I decided to design a replacement for Firmata. Design Requirements My first requirement was to try and simplify things. First, I would abandon the 7-bit bytes of Firmata and the whole SysEx messaging scheme. All data going across the link would be standard 8-bit bytes, and one messaging procedure would be used, not the 2 two used by Firmata. Next, telemetrix would use only the board descriptions built into the Arduino build infrastructure to provide pin mapping. Firmata, on the other hand, redefines things in its Boards.h file. When a new board is introduced, updating Boards.h can be very painful. The information in Boards.h is redundant to that provided in the board-specific Arduino core files. Telemetrix only uses board descriptions that are built into the board-specific Arduino core files. Releases In Phases Telemetrix will be released in the following phases.   Phase 1 Base Functionality          Debug capabilities                  Serial loopback utility          Ability to send values from the sketch and print them on the client console.                    Auto-detection of serial ports, including detection, locating, and connecting to a specific device.      Digital input      Digital and PWM output.      Analog input.      All inputs provide immediate notification of data changes.      A set of working examples for each function. Tested at a minimum on an Arduino Uno.            Phase 2 Servo Functionality         Phase 3 I2C Functionality         Phase 4 HC-SRO4 Distance Sensor Functionality     Phase 5 DHT Functionality.Trying Out Phase 1 For Yourself Phase 1 is available now if you wish to examine the code and try the examples. If you encounter any issues or have any questions, please enter an issue here. Step 1 - Download the distribution. Go to the telemetrix repository. Click on the green button to download the code and thenunzip the file. Step 2 - Upload arduino-telemetrix on your Arduino Go to the phase1/arduino-telemetrix directory to find arduino-telemetrix.ino. Upload this toyour Arduino. Step 3 - Try out the examples. Go to the phase1 directory. For Windows type: python3 setup.py installor for Linux and macOS sudo python3 setup.py installWith your Arduino connected to your computer, go to the phase1/examples directoryand try the loopback utility: python3 loop_back.pyYou should see A, B, and Z sent and looped back. You can then select and try out any of the other examples.Please note that you may need to adjust the pin numbers for your specific hardware setup. What’s Next In the next posting, I will be explaining the code on both the Python and Arduino sides in some detail. ","categories": ["arduino,stm32,firmata"],
        "tags": ["arduino"],
        "url": "http://localhost:4000/bots-in-pieces/arduino,stm32,firmata/2020/09/20/telemetrix-phase-1.html"
      },{
        "title": "Telemetrix Update 1",
        "excerpt":"I intended this posting to be  a discussion of both the client and server code,but I am postponing that discussion until the next posting when phase 2 is complete. I am converting the server sketch into a libraryso that it can be installed from the Arduino Library Manager. I am refactoring the sketch to make it simpler to add new commands.Also, I will be renaming the library to Telemetrix4Arduino. There may be an issue withthe Arduino trademark guidance with the previous name. These changes do not alter the phase 1 functionality, andthe phase 1 client works with the updated server. I am also integrating the Servo library. By doing so, I will better understand organizing the Arduino code so  that users do not have to go hunting around for the items that need modification when adding new commands or reports.The intent is to have everything that the user needs at the top of the file, clearlycommented. As a result, I can concentrate the next discussion on the code one would need to augment to add features,while providing some background on how the code works. ","categories": ["arduino,stm32,firmata"],
        "tags": ["arduino"],
        "url": "http://localhost:4000/bots-in-pieces/arduino,stm32,firmata/2020/09/27/telemetrix-update1.html"
      },{
        "title": "Phase 2 - Server And Client Details",
        "excerpt":"In this posting, we will discuss the phase 2 release. This release incorporates support for servos and refactors some of the Arduino code.Here is what will be covered today:   Installation of the phase2 server and client code.  A short discussion of what was changed in phase 2.  A quick look at possible future changes.  A discussion of the steps used in adding the servo support. This discussionwill include a partially detailed code description, and when appropriate, a “discussion detour” toexplain some concepts not directly part of the topic at hand.Support for servos is now available in the phase 2 directory of the telemetrix repository. An API is available at this link. There have been some significant changes made to the phase 1 code, and these will be discussed in a moment. For those who wish to try things out, here is what you need to do to install phase 2.       Go to the telemetrix repository and click on the green code button to download the .zip file.         Extract the files into a directory of your choice. A directory, called telemetrix-master, will be created, andit will contain all the necessary files.         Install the latest Arduino code by opening the Arduino IDE. From the main menu, go to Sketch, select Include Library, and then select Add .ZIP Library. Select the Telemetrix4Arduino.zip file in the telemetrix-master/phase2 directory. Finally, click on File from the IDE main menu and select Examples and thenselect Telemetrix4Arduino and upload the code to your device.         To install the phase2 Python code, cd to telemetrix-master/phase2, and then type:   # For Windows:python setup.py install# Or for macOS and Linux:sudo python3 setup.py installYou are now ready to try out the examples in the telemtrix-master/examples directory using phase 2 code. Note that you may need to change pin numbers in the examples to match yourhardware setup. All of the examples require the use of Python 3. What Has Changed In Phase 2   The Arduino code has been placed in an Arduino Library directory structure.          At some future time, the Arduino Library Manager may be used to install the code into the IDE.  Currently, you need to install usingthe .zip file, as shown above, since this library has yet to be published to be included in the Library Manager. All the code is maintained in a single file to help simplify adding features.        The Arduino code was renamed Telemetrix4Arduino.          The renaming was done to assure that there is no violation of the Arduino trademark.        A bug was fixed in processing incoming commands. The command handler was being called multiple times, and now, correctly,it is called once.  Arduino code was reorganized to make it easier to expand and add functionality.What Might Change For A Future Release Besides adding new features, I am considering using two additional Arduino librariesto make the code easier to understand and maintain. The first library is ArduinoJson. Currently, both command and report data is treated as an array of bytes. Indices into the array are used to createand parse these arrays. By using ArduinoJson, the data will be able to parsed using names instead of indices.Also, I intend to use the MessagePack feature of ArduinoJson to minimize the size of the messages being sent acrossthe serial link. The second library is the Embedded Template Library(ETL). ETL will allow the creation of more cohesive data structures to make the code easier to understand and maintain. When evaluating these libraries, the gating factors are the amount of memory space they will use and the impact on the speed of data transfers because the number of bytes for a given command or report will be somewhat larger than using the current array of bytes scheme. If these libraries are viable for Telemetrix4Arduino, it is not certain as of yet in which phasethey will be included. My current thinking is for phase 4 after I have implemented i2c support. The Steps Used To Add Servo Support To The Arduino Code Instead of going through all the code line by line, it is more beneficial to describe the stepsused in adding servo support. The code involved in each step will be both shown and discussed. If you are going through the code in detail and have any questions or comments, please post them below. Step 1: Decide Which Library Functions You Wish To Support I decided to expose the attach, write, and detach methods for client access via command messages for the servo library. Internally, the attached method is usedbut not exposed directly to the client. Step 2: Decide On Method Names To Support The New Commands And Expose Them As externs By defining the command functions using extern, the compiler will support forward referencing, and wedon’t need to worry about where the actual commands are defined within the file. // We first define the command functions here to provide a forward reference.// If you add a new command, you must add the command handler// here as well.// Phase 1 commandsextern void serial_loopback();extern void set_pin_mode();extern void digital_write();extern void analog_write();extern void modify_reporting();extern void get_firmware_version();extern void are_you_there();// Phase 2 commands - supporting the servo libraryextern void servo_attach();extern void servo_write();extern void servo_detach();Step 3: Add #defines For The New Command Values And Reports // Commands -received by this sketch// Add commands retaining the sequential numbering.// The order of commands here must be maintained in the command_table.#define SERIAL_LOOP_BACK 0#define SET_PIN_MODE 1#define DIGITAL_WRITE 2#define ANALOG_WRITE 3#define MODIFY_REPORTING 4 // mode(all, analog, or digital), pin, enable or disable#define GET_FIRMWARE_VERSION 5#define ARE_U_THERE  6#define SERVO_ATTACH 7#define SERVO_WRITE 8#define SERVO_DETACH 9// Reports - sent from this sketch#define DIGITAL_REPORT DIGITAL_WRITE#define ANALOG_REPORT ANALOG_WRITE#define FIRMWARE_REPORT 5#define I_AM_HERE 6#define SERVO_UNAVAILABLE 7#define DEBUG_PRINT 99The SERVO_UNAVAILABLE report is sent to the client if a servo_attach fails becausethere are no available servos. Step 4: Add Entries Into The command_table For The New Commands // When adding a new command update the command_table.// The command length is the number of bytes that follow// the command byte itself, and does not include the command// byte in its length.// The command_func is a pointer the command's function.typedef struct command_descriptor {    byte command_length;    void (*command_func)(void);};command_descriptor command_table[10] =        {                {1, &amp;serial_loopback},                {4, &amp;set_pin_mode},                {2, &amp;digital_write},                {2, &amp;analog_write},                {1, &amp;modify_reporting},                {0, &amp;get_firmware_version},                {0, &amp;are_you_there},                {5, &amp;servo_attach},                {2, &amp;servo_write},                {1, &amp;servo_detach},        };The command_table is an array of command_descriptors. The command value is used as an index into the array,so the command position in the table must match the command values defined in step 3. Make sure to increase the size of the table with each added command. A command_descriptor consists of two values. The first is the number of bytes ofdata that need to be retrieved after the command byte is received. The second is the address of the function that performs the processing of the command. DETOUR: The command function addresses are stored in the command table so that we can avoid having to use a large switch statement or a long list of if/elsestatements to de-reference a command.Instead, find_next_command uses the C language function pointersyntax to call the command function using the address in the table. void get_next_command() {    byte command;    int command_buffer_index = 0;    command_descriptor command_entry;    for (int i = 0; i &lt; MAX_COMMAND_LENGTH; i++) {        command_buffer[i] = 0;    }    if (Serial.available()) {        // get the command byte        command = (byte) Serial.read();        // uncomment the next line to see the command byte value        //send_debug_info(75, command);        command_entry = command_table[command];        //send_debug_info(command, command_entry.command_length);        // get the data for that command        if (command_entry.command_length &gt; 0) {            for (int i = 0; i &lt; command_entry.command_length; i++) {                // need this delay or data read is not correct                delay(1);                if (Serial.available()) {                    command_buffer[command_buffer_index++] = (byte) Serial.read();                    // uncomment out to see each of the bytes followning the command                    //send_debug_info(3, (int) command_buffer[command_buffer_index - 1]);                }            }        }        (command_entry.command_func());    }}Step 5: Allocate Any Global Storage That The Library Requires There is a fixed maximum number of servos that the library supports. Here we create an array of Servo objects. The servo library defines the MAX_SERVOS value. // servo managementServo servos[MAX_SERVOS];When a servo attach command is received, we need to determine if there are any servo objects available for use. To do this, we createan array of bytes that will aid in finding the first available servo objectthat we may use. If an available servo is found, thenthe pin number is entered in the pin_to_servo_index_map array, using the index returned by  thefind_servo function described below. byte pin_to_servo_index_map[MAX_SERVOS];Step 6: Implement The Command Functions /*************************************************** * Servo Commands **************************************************/// Find the first servo that is not attached to a pinint find_servo() {    int index = -1;    for (int i = 0; i &lt; MAX_SERVOS; i++) {        if (servos[i].attached() == false) {            index = i;            break;        }    }    return index;}The find_servo function is a helper function that iterates through the servos arrayto find the first available servo for use. It sequentially checks to see if a servo is currently attached. If not, it returns the index in the servo array. If there areno servos available, it returns a -1. void servo_attach() {    byte pin = command_buffer[0];    int servo_found = -1;    int minpulse = (command_buffer[1] &lt;&lt; 8) + command_buffer[2];    int maxpulse = (command_buffer[3] &lt;&lt; 8) + command_buffer[4];    // find the first avalable open servo    servo_found = find_servo();    if (servo_found != -1) {        pin_to_servo_index_map[servo_found] = pin;        servos[servo_found].attach(pin, minpulse, maxpulse);    } else {        // no open servos available, send a report back to client        byte report_message[2] = {SERVO_UNAVAILABLE, pin};        Serial.write(report_message, 2);    }}The servo_attach function is called by the get_next_command function when de-referencing an incomingSERVO_ATTACH command. Five additional bytes, in addition to the command byte, are required to process the servo_attach command.The first byte is the pin number. The next 2 bytes contain the high and low-value bytesfor the minimum pulse width to be used. These bytes are combined to form an integer.The last 2 bytes contain the high and low-value bytes for the maximum pulse width. These2 bytes are also combined to form an integer value. The servo_attach function calls find_servo. If a servo is available, the pinnumber is associated with the servo in the pin_to_servo_index_map array.If there are no available servos, a SERVO_UNAVAILABLE report is formed and sent across the serial link. DETOUR: In order to send values that are larger than a byte (ints, floats, etc.), the larger value needs to be broken down into byte-size chunks. By convention, we send the high order byte first, followed by the low order bytes. The receiver then reconstructs the actual value by combining the individual bytes in their proper orderto re-form the original value. Hopefully, ArduinoJson will preclude having to assemble and disassemble datavalues greater than a byte in length. // set a servo to a given anglevoid servo_write() {    byte pin = command_buffer[0];    int angle = command_buffer[1];    servos[0].write(angle);    // find the servo object for the pin    for (int i = 0; i &lt; MAX_SERVOS; i++) {        if (pin_to_servo_index_map[i] == pin) {            servos[i].write(angle);            return;        }    }}The servo_write command associates the supplied pin number with its associated servo instance, and then writes the supplied angle to the servo. // detach a servo and make it available for future usevoid servo_detach() {    byte pin = command_buffer[0];    // find the servo object for the pin    for (int i = 0; i &lt; MAX_SERVOS; i++) {        if (pin_to_servo_index_map[i] == pin) {            pin_to_servo_index_map[i] = -1;            servos[i].detach();        }    }}The servo_detach command disassociates the servo instance from the pin and makesthe servo instance available for reuse. The Steps Used To Add Servo Support To The Python Client Code Step 1: Update private_constants.py First, add the new commands and reports to private_constants.py. These values must matchtheir counterparts defined in the server. # commands# send a loop back request - for debugging communicationsLOOP_COMMAND = 0SET_PIN_MODE = 1  # set a pin to INPUT/OUTPUT/PWM/etcDIGITAL_WRITE = 2  # set a single digital pin value instead of entire portANALOG_WRITE = 3MODIFY_REPORTING = 4GET_FIRMWARE_VERSION = 5ARE_U_THERE = 6  # Arduino ID query for auto-detect of telemetrix connected boardsSERVO_ATTACH = 7SERVO_WRITE = 8SERVO_DETACH = 9# reports# debug data from ArduinoDIGITAL_REPORT = DIGITAL_WRITEANALOG_REPORT = ANALOG_WRITEFIRMWARE_REPORT = GET_FIRMWARE_VERSIONI_AM_HERE_REPORT = ARE_U_THERESERVO_UNAVAILABLE = SERVO_ATTACHDEBUG_PRINT = 99DETOUR: The ARE_U_THERE command and I_AM_HERE report are used to allow the clientto perform autodiscovery of a specific board plugged into your computer. The valuereturned by the I_AM_HERE report must match the expected Arduino ID value.You may change the Arduino ID values to accommodate multiple boards by setting the ID in the Telemetrix4Arduino sketch and using a matching value when instantiating the Telemetrix class. Step 2: For New Reports Update The report_dispatch Dictionary # The report_dispatch dictionary is used to process# incoming report messages by looking up the report message# and executing its associated processing method.# The value following the method is the number of bytes to# retrieve from the deque to process the report (not including report id).self.report_dispatch = {}# To add a command to the command dispatch table, append here.self.report_dispatch.update({PrivateConstants.LOOP_COMMAND: [self._report_loop_data, 1]})self.report_dispatch.update({PrivateConstants.DEBUG_PRINT: [self._report_debug_data, 3]})self.report_dispatch.update({PrivateConstants.DIGITAL_REPORT: [self._digital_message, 2]})self.report_dispatch.update({PrivateConstants.ANALOG_REPORT: [self._analog_message, 3]})self.report_dispatch.update({PrivateConstants.FIRMWARE_REPORT: [self._firmware_message, 2]})self.report_dispatch.update({PrivateConstants.I_AM_HERE_REPORT: [self._i_am_here, 1]})self.report_dispatch.update({PrivateConstants.SERVO_UNAVAILABLE: [self._servo_unavailable, 1]})By adding the name of the method to this dictionary, the callback for the report is invokedin a similar fashion to using a function pointer in C++. Step 3: Implement The Callback Method For The Report     def _servo_unavailable(self, report):        \"\"\"        Message if no servos are available for use.        :param report: pin number        \"\"\"        raise RuntimeError(f'Servo Attach For Pin {report[0]} Failed: No Available Servos')A RuntimeError is raised if no servos were available. Step 4: Implement The Command Methods set_pin_mode_servo The set_pin_mode_servo method is used to request a pin to beattached to a servo.     def set_pin_mode_servo(self, pin_number, min_pulse=544, max_pulse=2400):        \"\"\"        Attach a pin to a servo motor        :param pin_number: pin        :param min_pulse: minimum pulse width        :param max_pulse: maximum pulse width        \"\"\"        minv = (min_pulse).to_bytes(2, byteorder=\"big\")        maxv = (max_pulse).to_bytes(2, byteorder=\"big\")        command = [PrivateConstants.SERVO_ATTACH, pin_number,                   minv[0], minv[1], maxv[0], maxv[1]]        self._send_command(command)servo_write The servo_write method is used to move the servo to an angle between 0 and 180 degrees.    def servo_write(self, pin_number, angle):        \"\"\"        Set a servo attached to a pin to a given angle        :param pin_number: pin        :param angle: angle (0-180)        \"\"\"        command = [PrivateConstants.SERVO_WRITE, pin_number, angle]        self._send_command(command)servo_detach To free-up a servo for reuse, servo_detach is called.     def servo_detach(self, pin_number):        \"\"\"        Detach a servo for reuse        :param pin_number: attached pin        \"\"\"        command = [PrivateConstants.SERVO_DETACH, pin_number]        self._send_command(command)Concluding Remarks Adding support for a new library is accomplished by following the steps outlined above. We will be using a similar methodology as telemetrix functionality is expanded. ","categories": ["arduino,telemetrix,servo"],
        "tags": ["arduino,servo"],
        "url": "http://localhost:4000/bots-in-pieces/arduino,telemetrix,servo/2020/10/03/telemetrix-phase2_code-discussion.html"
      },{
        "title": "Phase 3 - I2C Support",
        "excerpt":"I2C Support Telemetrix Phase 3 has been released, implementing i2c support. You can view the Python3 APIhere. To use the i2c API, you must first call set_pin_mode_i2c once within your application, independentof how many i2c devices your application supports. Once set_pin_mode_i2c is called, the i2c read and write methods  interact with the individual i2c devices. An example i2c application for the ADXL345 accelerometer may be  viewed here.. Installing Phase 3       Go to the telemetrix repository and click on the green code button to download the .zip file.         Extract the files into a directory of your choice. A directory, called telemetrix-master, will be created, andit will contain all the necessary files.         Install the latest Arduino code by opening the Arduino IDE. From the main menu, go to Sketch, select Include Library, and then select Add .ZIP Library. Select the Telemetrix4Arduino.zip file in the telemetrix-master/phase3 directory. Finally, click on File from the IDE main menu, and select Examples and thenselect Telemetrix4Arduino and upload the code to your device.         To install the phase3 Python code, cd to telemetrix-master/phase3, and then type:   # For Windows:python setup.py install# Or for macOS and Linux:sudo python3 setup.py installYou are now ready to try out the examples in the telemtrix-master/examples directory using phase 3 code. Note that you may need to change pin numbers in the examples to match yourhardware setup. All of the examples require the use of Python 3. What’s Next Try ArduinoJSON For Building Serial Communication Messages I want to experiment using ArduinoJson for data transfer between the Python client and the Arduino server. I may also try implementing Telemetrix for the ESP-8266 performing data transfer between the clientand server over WiFi. I will be basing this off of the following links:   Get raw P2P Message from NodeMCU or ESP8266  Getting raw TCP / IP messages from NodeMCUSupporting The HC-SR04 and DHT on Arduino Uno Here is what the Arduino IDE reports when installing Telemetrix4Arduino for phase 3 on an Uno: Sketch uses 7274 bytes (22%) of program storage space. Maximum is 32256 bytes.Global variables use 1471 bytes (71%) of dynamic memory, leaving 577 bytes for local variables. Maximum is 2048 bytes.Space is becoming tight. I may surround the code supporting these two features with #ifdefs to  make the build configurable by defining values at the top of the file.  If this works out well, userscan do the same for all the features and then select the supported features they want, butdepending upon the board being used, they may not be able to select all. Why ESP-8266 or ESP32 Support Is Important For robotics type activities, untethered remote control is a necessity. Communicatingover TCP/IP provides a robust link and is not as fussy as a Bluetooth link.More on this as my experiments progress. ","categories": ["arduino,telemetrix,i2c"],
        "tags": ["arduino,i2c"],
        "url": "http://localhost:4000/bots-in-pieces/arduino,telemetrix,i2c/2020/10/06/telemetrix-phase3-i2c.html"
      },{
        "title": "Telemetrix Phase 4 - HC-SRO4 Sonar Distance Sensor Support",
        "excerpt":"A Slight Change Of Plan I decided to implement support for the HC-SR04 SONAR distance sensors and not delay it to a future phase. I’ve tested the current code on both an Arduino Uno and an STM32 Pro Black Pill STM32F411CEU6. Some Implementation Details Up to 6 HC-SR04 sensors are supported. The distance reports for all sensors consist of a list containing the following: [PrivateConstants.SONAR_DISTANCE, trigger_pin, distance_value, time_stamp]The distance value is expressed in centimeters. Adding A New HC-SR04 Device The Python set_pin_mode_sonar method is used to add HC-SR04 devices. It takes three parameters, the trigger pin, echo pin, and a mandatory callback function.  Currently, all six HC-SR04 sensors share acommon callback function. However, this may be changed in the future so thateach sensor has its own callback. When the Arduino core board receives a request to add an additional HC-SR04, the sonar_new function is called. HC-SR04 instances are identified by the trigger pin number specified for the device. The code for managing the HC-SR04 devices is provided below: // HC-SR04 Sonar Management#define MAX_SONARS 6typedef struct Sonar{    uint8_t trigger_pin;    Ultrasonic *usonic;};Sonar sonars[MAX_SONARS];byte sonars_index = 0; // index into sonars structbyte last_sonar_visited = 0;unsigned long sonar_current_millis;        // for analog input loopunsigned long sonar_previous_millis;       // for analog input loopuint8_t sonar_scan_interval = 33 ;         // Milliseconds between sensor pings.                                           // 29ms is about the minimum to avoid crosstalkvoid sonar_new(){    if(sonars_index == MAX_SONARS){        byte report_message[1] = {SONAR_MAX_EXCEEDED};        Serial.write(report_message, 1);        return;    }    sonars[sonars_index].usonic = new Ultrasonic((uint8_t)command_buffer[0],                                                   (uint8_t)command_buffer[1],                                                 80000UL);    sonars[sonars_index].trigger_pin = command_buffer[0];    sonars_index++;}void scan_sonars(){    unsigned int distance;    if(sonars_index) {        sonar_current_millis = millis();        if (sonar_current_millis - sonar_previous_millis &gt; sonar_scan_interval) {            sonar_previous_millis += sonar_scan_interval;            distance = sonars[last_sonar_visited].usonic-&gt;read();            byte report_message[4]  = {SONAR_DISTANCE, sonars[last_sonar_visited].trigger_pin,                                       (byte)(distance&gt;&gt;8), (byte)(distance &amp; 0xff)};            Serial.write(report_message, 4);            last_sonar_visited ++;            if(last_sonar_visited == sonars_index){                last_sonar_visited = 0;            }        }    }}Reading The HC-SRO4 Devices The sensors are read sequentially, with 33 milliseconds between reading each sensor to ensure that they do not interfere with one another. Please note that the more HC-SR04 devicesadded, the longer it will be before the first sonar device is reread. If there is onlyone HC-SR04 device, it will be read every 33 milliseconds, but if there are the full six HC-SRO4 devices enabled, a full scan of all six will take 198 milliseconds. What Comes Next I am evaluating using ArduinoJson to serialize the data that is transmitted across the serial link.  The decision to use ArduinoJson will depend on the storage space and data transfer rate overhead added by using ArduinoJson.MessagePack with ArduinoJson will also be tested, which should lessen the overheadused with ArduinoJson in pure JSON mode. ","categories": ["arduino,telemetrix,hc-sr04,sonar"],
        "tags": ["arduino,i2c,hc-sr04,sonar"],
        "url": "http://localhost:4000/bots-in-pieces/arduino,telemetrix,hc-sr04,sonar/2020/10/10/phase4-sonar.html"
      },{
        "title": "Evaluating ArduinoJson",
        "excerpt":"Why Am I Evaluating ArduinoJson? Currently, all data transferred between the Arduino Server and Python Client is in binary, positionally dependent form. When receiving a serializeddata packet, the receiver must associate the command or report descriptor with thenumber of bytes that comprise the packet. Suppose we look at the client-side report_dispatch dictionary shown below.For every expected report, the dictionary references a method that will process the report and the number of bytes that follow the report identifier used to process it. # The report_dispatch dictionary is used to process        # incoming report messages by looking up the report message        # and executing its associated processing method.        # The value following the method is the number of bytes to        # retrieve from the deque to process the report (not including report id).        self.report_dispatch = {}        # To add a command to the command dispatch table, append here.        self.report_dispatch.update({PrivateConstants.LOOP_COMMAND: [self._report_loop_data, 1]})        self.report_dispatch.update({PrivateConstants.DEBUG_PRINT: [self._report_debug_data, 3]})        self.report_dispatch.update({PrivateConstants.DIGITAL_REPORT: [self._digital_message, 2]})        self.report_dispatch.update({PrivateConstants.ANALOG_REPORT: [self._analog_message, 3]})        self.report_dispatch.update({PrivateConstants.FIRMWARE_REPORT: [self._firmware_message, 2]})        self.report_dispatch.update({PrivateConstants.I_AM_HERE_REPORT: [self._i_am_here, 1]})        self.report_dispatch.update({PrivateConstants.SERVO_UNAVAILABLE: [self._servo_unavailable, 1]})        self.report_dispatch.update({PrivateConstants.I2C_READ_REPORT: [self._i2c_read_report, 1]})        self.report_dispatch.update({PrivateConstants.I2C_TOO_FEW_BYTES_RCVD: [self._i2c_too_few, 1]})        self.report_dispatch.update({PrivateConstants.I2C_TOO_MANY_BYTES_RCVD: [self._i2c_too_many, 1]})        self.report_dispatch.update({PrivateConstants.SONAR_MAX_EXCEEDED: [self._sonar_max_exceeded, 0]})        self.report_dispatch.update({PrivateConstants.SONAR_DISTANCE: [self._sonar_distance_report, 3]})Using the ANALOG_REPORT as an example, we see that there are three additional bytes needed to be read from the serialport after receiving the ANALOG_REPORT identifier byte. The report as sent by the Arduino consists of the following bytes:   The ANALOG_REPORT identifier.  The pin number.  The high order byte of the reported value.  The low order bytes of the reported value.Advantages Of the Current Serialization Scheme   Small packet size.  Fast data transfer.Drawbacks Of The Current Serialization Scheme   The number of bytes in a packet has to be matched on both the sender and receiver sides.  For a packet containing a variable number of bytes, for example, the i2c_write command, the number of variable bytes needs to be incorporated as a data field within the packet. The command or report handler then reads that number of bytes from the serial port before proceeding with the packet’s processing.  The only data type represented in this scheme is a byte. When a larger data type is needed, the sender needs to disassemble the data into bytes, and the receiver needs to reassemble the bytesinto the desired data type.  The data is in binary form and cannot be easily viewed with a serial monitor.Can ArduinoJson Help Resolve These Drawbacks? I wanted to explore if there was a better way to serializethe data going across the link. ArduinoJson was a possible solution. ArduinoJson is a JSON library built explicitly for Arduino MCUs. JSONallows us to describe the data in a positionally independent manner, usingkey/value pairs. It also directly supports data types larger than a byte. For example, here is a JSON representation of an i2c_write command packet. { \"command\": i2c_write, \"address\": I2C_DEVICE_ADDRESS, \"bytes_to_write\": [byte 1, byte2, ...] }The variable portion of the data is represented as an array, and no additional reads are necessary to retrieve them. They are just part of the JSON packet that is retrieved using the key.If JSON is a viable solution, we also no longer need to match packet sizes on both the client and server-side. Advantages Of JSON   Handles data types larger than a byte.  Precludes the need to coordinate packet sizes for the server and client.  Because the data is human-readable, the packets can be looked at with a serial monitor.So why not just go with JSON? Because JSON packets will be larger than the binary packets. For example, if we build a packet with the schema of: {  \"count\": 0,  \"type\": \"r\",  \"device\": \"i2c\",  \"address\": 83,  \"register\": 232,  \"big_data\": 2048,  \"data\":[1,2,3,4,5,6]}If we implement this schema using the current binary serialization method, we will end up with a 13 byte packet. Unlike the JSON representation, the string values wouldbe translated to byte values.  For example, instead of the “device” field being set to “i2c”, it wouldbe set to some value, such as 44. // The data and types we wish to send across the linkint count = 0;byte mtype = 1;byte device = 44;byte the_register = 232;int big_data = 2048;byte the_data[6] = {1, 2, 3, 4, 5, 6};// prebuild the packetbyte the_buffer[13]= {highByte(count), lowByte(count), mtype, device, the_register, highByte(big_data),lowByte(big_data), 1, 2, 3, 4, 5, 6};Using the same schema with JSON, the packet length expands to 102 bytes. The ArduinoJson libraryalso introduces additional overhead in processing time and memory utilization. MessagePack - A Variant Of JSON There is a third alternative called MessagePack that is supported by ArduinoJson. MessagePack serializes the  data using compression techniques. For the example shown above, the length of the packet is reduced from 102 bytes to 70. Drawbacks Of ArduinoJson And MessagePack   Larger packet lengths.  Additional time to transmit the larger packets.  Additional processing time for serialization.  Larger memory footprint to accommodate the library.So Is ArduinoJson The Answer? The advantages of ArduinoJson over the current serialization scheme are significant,but the question remains, do the drawbacks outweigh the benefits? To find out, I created three test scenarios with a client and server for each scenario. The code was runon an Arduino Uno.You can view the code for all three scenarios on GitHub. They all use a similar data scheme. Because there is more likely to be a highervolume of traffic coming from the Arduino when using Telemetrix, data will begenerated from the Arduino side only. Each test scenario generates a thousandpackets. The elapsed time for the 1000 packet transmission is calculated. Here are the results: Serialization Times Current Serialization:      Elapsed time = 1.1839430332183838 seconds MessagePack Serialization:  Elapsed time = 6.156056642532349  seconds JSON Serialization:         Elapsed time = 8.810443878173828  seconds Packet Lengths: Current Serialization:      13 bytes MessagePack Serialization:  70 bytes JSON Serialization:         102 bytes Arduino Footprint Current Serialization:Sketch uses 1682 bytes (5%) of program storage space. Maximum is 32256 bytes. Global variables use 200 bytes (9%) of dynamic memory, leaving 1848 bytes for local variables. Maximum is 2048 bytes. MessagePack Serialization: Sketch uses 3576 bytes (11%) of program storage space. Maximum is 32256 bytes. Global variables use 567 bytes (27%) of dynamic memory, leaving 1481 bytes for local variables. Maximum is 2048 bytes. JSON Serialization:Sketch uses 5478 bytes (16%) of program storage space. Maximum is 32256 bytes. Global variables use 514 bytes (25%) of dynamic memory, leaving 1534 bytes for local variables. Maximum is 2048 bytes. Conclusion There are many advantages to using JSON, but unfortunately, the throughput performance could not meet the Telemetrix Project’s needs.  Also, its footprint is large when compared to the original serialization method. Therefore,the original serialization scheme for transmitting and receiving serial data will be used. I am exploring a variant on the current serialization scheme. In this scheme, the packet’s length is calculated and placed in the packet’s first byte, eliminating the need to store the number of bytes in a packet as part of a lookup table. If this variantdoes not add additional overhead, it will be considered to be used sometime in the future. If adopted, a posting on this blog will be made. ","categories": ["arduino,telemetrix,arduinojson"],
        "tags": ["arduino,arduinojson"],
        "url": "http://localhost:4000/bots-in-pieces/arduino,telemetrix,arduinojson/2020/10/10/telemtrix-arduinojson.html"
      },{
        "title": "Telemetrix And Telemetrix-AIO",
        "excerpt":"This week phase 5 of Telemetrix and the new Python asyncio client, Telemetrix-AIO, were both released.Phase 5 of Telemetrix retains the original Python API but makes some significant changes to both the client and the server’s internals. Packet Length Added To Both Command and Report Packets To simplify adding features to Telemetrix, command and reporter packets now append the packet’s length before sending it across the serial link.Not only does this make debugging more manageable, but the size of a packet no longer needs to be maintained by both the client and the server. Support Provided For Processors That Contain A Second i2c Port Has Been Implemented Some processors, such as the STM32 F411CEU6, contain a second i2c port. To turn onsupport for those processors, un-comment out the following line in the Telemetrix4Arduino sketch: //#define SECOND_I2C_PORTIf you are using the second i2c port, you will need to specify which port you wish to use: def set_pin_mode_i2c(self, i2c_port=0)def i2c_read(self, address, register, number_of_bytes,                 callback=None, i2c_port=0)def i2c_read_restart_transmission(self, address, register,                                      number_of_bytes,                                      callback=None, i2c_port=0)def _i2c_read_request(self, address, register, number_of_bytes,                          stop_transmission=True, callback=None, i2c_port=0)def i2c_write(self, address, args, i2c_port=0)If you are using only the default i2c port, you do not need to specify an i2c port at all. If you are using the second i2c port, the default pins used for that port are defined in the Telemetrix4Arduino sketch. #define SECOND_I2C_PORT_SDA PB3#define SECOND_I2C_PORT_SCL PB10These are the pin numbers for the STM32. Redefine these to the pins that are specific to your board. Each HC-SR04 Distance Sensor Has A Unique Callback Previously, there was a single shared callback for all HC-SR04 sensors. You may now associate a uniquecallback for each HC-SR04 in use. DHT Temperature Sensor Support Put On Hold DHT sensor support will be used in an upcoming article to demonstrate the procedure used to add library support for both the client and the server. Telemetrix-AIO Available For Download Telemetrix-AIO is a Python asyncio client with a similar API to that of the non-asyncio version. Why asyncio? Recently I captured a snapshotof the download statistics from pypi for both the pymata4 (non-asyncio) and pymata-express (asyncio)libraries, and much to my surprise, pymata-express is being downloaded at a significantly higher rate than pymata4. Here are the rates as of this writing on October 22, 2020: pymata4: Total downloads10,054 Total downloads - 30 days693 Total downloads - 7 days232 pymata-express Total downloads37,766 Total downloads - 30 days5,594 Total downloads - 7 days1,665 What’s Next? I will be writing the documentation for both Telemetrix and Telemetrix-AIO. Following that,I will be writing an article on extending both versions using the DHT sensor as an example.When all that is complete, I will be working on an ESP-8266 version of Telemetrix and Telemetrix-AIO. ","categories": ["arduino,telemetrix,stm32"],
        "tags": ["arduino"],
        "url": "http://localhost:4000/bots-in-pieces/arduino,telemetrix,stm32/2020/10/23/telemetrix-phase-5.html"
      },{
        "title": "Telemetrix And Telemetrix-AIO Phase 6",
        "excerpt":"I just published what I believe will be the last of the beta versions for both telemetrix and telemetrix-aio. I have reversed my previous decision about support for the DHT and included minimalist supportfor the DHT 22 sensor. Implementing DHT support will permit me to use the DHT code as a use case on how to add hardware support to both telemetrix and telemetrix-aio for devices of your choice. One of the main goals of telemetrix is to be friendly enough for users to feel comfortable extending it to meet their own needs. What Has Changed For This Release The features added are:   Minimal support for the DHT 22 sensor. Note: only the DHT22 is supported in this release.  A new command to allow you to set the scan interval for analog inputs.  The facility to set a differential threshold when setting the pin mode for analog inputs. If you have a sensorthat oscillates between a range of values, and you wish to ignore these oscillations, you may do so using this feature.  Upon shutdown, a message is sent to Telemetrix4Arduino to stop all reports from being generated. Doing so helps to alleviate “junk” data being received when an application is restarted.  Also, some code cleanup and reorganization were performed.What Is Next I will be writing the documentation for both packages. When that is complete, I will publish version 1of both packages. Also, Telemetrix4Arduino will be published to the Arduino package manager so thatthe Telemetrix4Arduino library may be loaded using the Arduino IDE. Stay safe, stay well, and stay tuned. ","categories": ["arduino,telemetrix,stm32"],
        "tags": ["arduino"],
        "url": "http://localhost:4000/bots-in-pieces/arduino,telemetrix,stm32/2020/10/29/telemetrix-phase6.html"
      },{
        "title": "Telemetrix And Telemetrix-AIO Have Been Officially Released",
        "excerpt":"Both Telemetrix and TelemetrixAIO have been officially released today. A userguide is available online. So what is next? I will be working on a version of Telemetrix4Arduino (the Telemetrix Sketch) for the ESP-8266 so thatit can be controlled over WiFi. Stay tuned! Stay Safe! ","categories": ["arduino,telemetrix,stm32"],
        "tags": ["arduino"],
        "url": "http://localhost:4000/bots-in-pieces/arduino,telemetrix,stm32/2020/11/09/telemetrix-released.html"
      },{
        "title": "Telemetrix4Esp8266 Released",
        "excerpt":"As promised in the previous post, an ESP8266 Telemetrix sketchhas been released. It is compatible with both the telemetrix and telemetrix-aio clients. What’s Next? I am currently working on a server and clients for the ESP32. I decided to create new branches for the clients because of specific  ESP32 features, such as touch pins. I could have put these features in the current clients but wanted to make an explicit distinction for ESP32 support.For future releases, I am planningTelemetrix support for the Adafruit Circuit Playground Express, Adafruit Circuit Playground Bluefruit, and micro:bit V2. For the Playground Express Bluefruit and micro:bit, I plan to support both serial and BLE data transports. Until next time, stay safe. ","categories": ["arduino,telemetrix,esp8266"],
        "tags": ["arduino"],
        "url": "http://localhost:4000/bots-in-pieces/arduino,telemetrix,esp8266/2020/12/06/telemetrix-esp8266-released.html"
      },{
        "title": "Adding ESP32 To The Telemetrix Family",
        "excerpt":"For those celebrating at this time of the year (and to those who may not be celebrating), I wish to extend my best wishes for health, happiness,and prosperity. This posting is just a quick update on what I have been working on. As of late, most of my efforts have been centeredaround the Telemetrix Project. Support has been provided for Arduino, STM32, and ESP8266 MCUs. The latestefforts are devoted to the ESP32. The ESP32 has been somewhat of a challenge. Things are somewhat non-standard as to how things like pin modes are represented in the ESP32 Arduino Core, which caused a little confusion but is resolved now.I have a non-asyncio version that runs over WiFi. My next goal is to get serial over Bluetooth and BLE functioning.Easier said than done. Bluetooth turns out to be a maze of twisty little mazes. Many of the articles I have found have not been very helpful, but I found what I believe is a treasure trove of information that hopefully will allow meto make some progress. The information is located on the techtutorialsx blog. Here is a list of articles from that blog that I hope will be useful. ESP32 Bluetooth: Using the BTstack library ESP32 Bluetooth: Finding the device with Python and BTStack ESP32 Arduino Bluetooth classic: Getting started ESP32 Arduino Bluetooth Classic: Setting the device name ESP32 Arduino: Serial communication over Bluetooth Hello World) ESP32 Arduino: Getting the Bluetooth Device Address ESP32 Arduino Serial over Bluetooth: Receiving data ESP32 Arduino Bluetooth: Finding the device with Python ESP32 Arduino Bluetooth Classic: Controlling a relay remotely ESP32 Arduino Serial over Bluetooth: Client connection event ESP32 Arduino Serial over Bluetooth: Client disconnection event ESP32 Arduino Serial over Bluetooth: Get client address My goal is to be able to auto-discover the ESP32 within the Telemetrix Python client without having to force the userto do any manual steps to create the connection. If it turns out that I cannot achieve this goal, I most likely will abandon Bluetooth and BLE support for the ESP32. Hopefully, I will be able to figure it out ;-). See you in the New Year. ","categories": ["arduino,telemetrix,esp32"],
        "tags": ["arduino"],
        "url": "http://localhost:4000/bots-in-pieces/arduino,telemetrix,esp32/2020/12/24/telemetrix-end-of-year-update.html"
      },{
        "title": "Some Thoughts On The Importance Of The Raspberry Pi 2040",
        "excerpt":"Last week, as I was trying to solve the mysteries of Bluetooth programming (more on that in a future post), I received an email announcing the Raspberry Pi Pico’s arrival. Quickly glancing at the Pico’s description, my first thoughts were, “YAAA” (yet another Arduino alternative). I yawned and went back to the frustrations of Bluetooth (or maybe we should call it Root Canal) programming. Not long after, more emails arrived - one from Sparkfun, another from Adafruit, another from Pimoroni, and more from other hardware vendors. All were announcing they were going to release boards designed around the Raspberry Pi RP2040 chip. Even Arduino announced it is going to get on board with the RP2040. I was blown away. As significant as the accomplishment of the RP2040 is for the Raspberry Pi team, in my opinion, the real achievement was coordinating releases by all the major hardware vendors. Never before have so many competitors coalesced around a single chip, all announcing on the same day. Why is this so consequential? First, each hardware manufacturer will be building boardsto support their own unique eco-system. For example, Adafruit will be building on the Feather, and Sparkfun is developing several unique offerings around their eco-system. This in and of itself is exciting because if you have bought into a manufacturer’s eco-system, you can still use their peripherals with the new chip. This is really neat, but for me, the significant accomplishment is that there will be unified software support structure across all the boards and manufacturers. With the RP2040, one can program in C if you wish to go that route. And in fact, Arduino will be releasing an Arduino Core for the RP2040. In addition, MicroPython and its derivative, CircuitPython is available right at the starting gate. Not only can you pick a board form factor and hardware eco-system, but your software efforts also have a high probability of being portable between the various boards, form factors, and eco-systems. I don’t know how the Raspberry Pi folks managed to pull off such a coordinated effort among this modern-day version of a “Team of Rivals.” Pure genius! Imagine coordinating a chip design, software support, and portability between rival manufacturers, and having them all announce on thesame day is really something to marvel over. And now, even more, are jumping on the bandwagon. Seeed Studio just announcedGrove support for the Pico. All we need now are for the headers to be pre-soldered on theboard offerings! Well done, Raspberry Pi! In this time of great sadness and worry, it is nice to see such cooperation and hope for the future. ","categories": ["Raspberry","Pi"],
        "tags": ["MCU"],
        "url": "http://localhost:4000/bots-in-pieces/raspberry/pi/2021/01/28/RP2040.html"
      },{
        "title": "I've Got The Bluetooth Blues",
        "excerpt":" I’ve been working on providing a Bluetooth version of Telemetrix for several devices since before the New Year. To put it mildly, it has been slow going and sometimes exasperating. For those of you who know my work, I prefer to support Linux, macOS, and Windows. Unfortunately, for Bluetooth, both Classic and BLE, this will not be possible. Windows does not seem to be supported for Python, nor for NodeJS. I should have realizedthis when reading articles on developing Bluetooth - Windows is never mentioned.  No Windows test tools or libraries in-sight. The Python PyBluez library can be compiled for Windows, but that involves installing a version of Visual Studio to do so. I would not even think about suggesting that for my Windows users. It would turn into a support nightmare for the users and me. For Bluetooth classic RFCOMM using PyBlueZ, I do have a working prototype. I also have a working prototype for BLE using the Python Bleak library for the Nordic UART Service. However, Bleak is a Python asyncio library, so it may not be everyone’scup of tea. Bleak, which is supposed to work with Windows, has known Windows issues that make it a no-go on Windows for me. So what does this boil down to? Here is a table of devices and their intended Telemetrix support. This should work for bothLinux and macOS, but I have no way of testing the mac, so there are no guarantees mac will work (but it should). I also cannot guarantee a timeframe. Since the ESP32 is the easiest device to work with, I will be completing that first, and its code will act as a template for the other devices. Unfortunately, I cannot predict a timeframe since Bluetooth seemsto enjoy surprising me. Stay tuned for periodic updates as progress is made.             Device      Classic Bluetooth Non-Asyncio      BLE Asyncio With Bleak      BLE Non-Asyncio With PyBlueZ                         ESP32      Yes      Yes      To Be Investigated                     micro:bit v2      Device does not support this mode      Yes      To Be Investigated                     Adafruit CircuitPlayground Bluefruit      Device does not support this mode      Yes      To Be Investigated             ","categories": ["bluetooth"],
        "tags": ["bluetooth","telemetrix"],
        "url": "http://localhost:4000/bots-in-pieces/bluetooth/2021/01/28/bluetooth-blues.html"
      },{
        "title": "An Act Of Random Kindness",
        "excerpt":"I recently tweeted about my Raspberry Pi Pico postingand received a reply from Simon Walters (aka @cymplecy).Simon is famously known for S3GPIO, amongst other efforts in supporting physical computing education in the U.K. Knowing that I have been mucking around Firmata support for Python over the past several years, Simon suggested adding similar support for the Pico. I lamented about not being able to obtain a Pico yet here in the U.S. In a private email, Simon offered to send me one, and I accepted. I can’t thank Simon enough.  As I anxiously await the Pico’s arrival, I have been busy reading the Raspberry Pi Pico documentation. Using the documentation as a guide, I have successfully set up development environments for coding the Pico, both on a Raspberry Pi4 and my Ubuntu 20.10 box. As mentioned in the Tweet, my intention is to provide a Telemetrix server for the Pico, and a Telemetrix Python client capable of running on Linux, Windows, and macOS. Essentially, Telemetrix allows you to send commands from your PC to the MCU to perform normal operations such as GPIO and i2c control from a fixed application running on the MCU. In addition, it automatically monitors and reports any changes to input data. Since the Pico provides both C language and Micropython SDKs,  the firstproblem for me to solve is which SDK to use. From a pleasurable programming point of view, Python would be my first choice. Having done similar projects that required similar decisions to be made, my experience has been that MicroPython’s efficiency for sending data across a serial link is rather sluggish. However, the RP2040, the Pico’s processor, is not a “normal” processor. Without getting into the details, the RP2040 has the capability of providing optimized support for I/O communication. The first thingthat I will do is write a quick and dirty “benchmark” in both C and MicroPython to determine which to use. I will publish both the code and findings so that you may see how I chose the “winning” SDK. Let’s all pull for MicroPython! That’s it for now. Stay tuned for my Pico adventures. And once again, thanks, Simon. Not only for the offer of the board but for the distraction from dealing with Bluetooth ;-). ","categories": ["Raspberry","Pi","Pico"],
        "tags": ["MCU"],
        "url": "http://localhost:4000/bots-in-pieces/raspberry/pi/pico/2021/02/03/act-of-random-kindness.html"
      },{
        "title": "Adventures With The Raspberry Pi Pico - Part 1",
        "excerpt":"The Pico arrived safely from across the pond. Simon Walters not only took thetime to package it up but also pre-wired headers to the board. Well-done Simon! So, like many things in life, the Pico had some surprises in store. I made someassumptions about the board which, turned out not to be entirely correct. You know theoldsaying about assuming, “Assuming makes an ass out of you and me.” If you are not anative English speaker, the expression is a play on the spelling of the word “assume.” Now, back to the board. I compiled a couple of the examples from the C SDK without issue,andwhen I went to flash the code, I encountered my first “problem.” TheGetting Started Guide is somewhat ambiguous about how to put the board into “flash” mode. They say to press the BOOTSEL button but do not explicitly mention to do so before applying power to the Pico. There is now a “quick start area” on the RPi Pico documentation page that clearly explains this. It even incorporates an animated graphic. Just scroll down to the “Welcome to your Raspberry Pi Pico” section  of the page and click on “Getting started with C/C++.”  I first uploaded the “blink” example and then the “hello_usb” example, and both workedwithout issue. My next self-assigned task was to create a super-simple example to send data across the serial link and have it looped back using the USB connector on the Pico. It seemed like a no-brainer since “hello-usb” worked. I wanted to use the UART library to do so, but after reading the  SDK source code, the UART library uses 2 GPIO pins for data transfer. The SDK implies  that  one  would need to connect either an RPi or use a USB-to-TTL converter to use the UART   library. My original intent was to use a USB cable between the computer and   the Pico and have bidirectional binary data flowing between the two. If some type of    USB-to-TTL converter is necessary, there is an extra expense and added complication.    Something I hope to be able to avoid. So, what to do? The “hello_usb” example uses the stdio printf function to send dataacross the serial link. The low-level UART library is not available for aUSB to USB connection.  After a little bit of head-scratching, it dawned on me (sometimes I am a little slow on the uptake) to use other functions in the stdio library to send and receive data on the Pico over a USB cable. This revelation was non-obvious because the only stdio function mentioned in the C SDK documentation is printf. So I gave it a shot, and low and  behold, it worked. Here is code for the Pico side of the application. It is an adaptation of the “hello_usb”program: #include &lt;stdio.h&gt;#include \"pico/stdlib.h\"int main() {    char buffer[30];    stdio_init_all();    while (true) {        //printf(\"Hello, world!\\n\");        //putchar('z');        //sleep_ms(1000);        fgets(buffer, 5, stdin);        printf(buffer);    }    return 0;}It performs a read using fgets, and then turns around and sends the same data back usingprintf. The Python script running on my PC is as follows: import serialimport timeclass TPutComp:    def __init__(self, runs):        self.serial_port = serial.Serial('/dev/ttyACM0', 115200,                                         timeout=1, writeTimeout=0)        start_time = time.time()        for i in range(runs):            self.serial_port.write('abcde\\n'.encode())            data = self.serial_port.readline(7).decode()            if data != 'abcde\\r\\n':                raise RuntimeError        elapsed = time.time() - start_time        print(f'{i+1} Iterations elapsed time: {elapsed}')        print(f'Calculated single iteration: {elapsed / runs}')TPutComp(100)This script uses the serial port to send out the string, “abcde” and waits untilthat string returns the same string. The termination characters are an artifact of usingstdio on the Pico side. This sequence repeats for the number of iterations specified inthe run parameter. Here is an output sample: 100 Iterations elapsed time: 0.3622300624847412Calculated single iteration: 0.0036223006248474123Process finished with exit code 0I hoped to create a MicroPython script to compare serial throughput between C and MicroPython. However,the version of MicroPython supplied for the Pico requires a USB-to-TTLconverter to support serial communication. So, for now, a MicroPython version of Telemetrix for the Pico is on hold. I first wantto try using the USB-to-TTL converter with a modified version of the uart_modified.cexample provided with the C SDK. If there is no appreciable performance gainbetween that andthe stdio version, I will then abandon my hopes for using MicroPython. However, if there isa noticeable performance gain, I will then implement a MicroPython script using the UART library and run a performance comparison between the C and Python SDKs. Stay tuned for the results. ","categories": ["Raspberry","Pi","Pico"],
        "tags": ["MCU"],
        "url": "http://localhost:4000/bots-in-pieces/raspberry/pi/pico/2021/02/12/pico-adventures-part1.html"
      },{
        "title": "Adventures With The Raspberry Pi Pico - Part 2",
        "excerpt":"Before beginning this discussion, I thought I would take the opportunity to thank Les Pounder for his Pico articles in Tom’s Hardware. If you scroll down to the bottom ofthis article,Les provides links for some very beneficial information. I used his reset button tutorialthat makes reprogramming quick and easy. Now on to the matter at hand. If you recall, my overall intention is to provide aTelemetrix interface so that the Pico may be programmed remotely using standard Python 3 from your PC or Raspberry Pi. Telemetrix is wholly dependent on having a communications link between the PC and the MCU. In the case of the Pico, currently, that link is a serial link running at 115200. In the last posting, I ran a quick and dirty test to loop back a short data string that originated from a PC. The serial interface used was the USB connector on the Pico, and the library for input and output was stdio. The intention was to time how long a round trip would take for a single iteration of looping back the string. I was curious if there might be a speed advantage in using the Pico UART library over the previous experiment. To use the UART library, one must connect a TTL-to-USB converter module to the Pico.  I modified uart_advanced.cthat is provided in the Pico examples directory. I also modified the Python script I used in the previous posting to use the communications port assigned to the converter. What I found was surprising. A single round trip of 5 characters took over a second to perform. I am probably missing something, but I could not find any delays within the example code. Interestingly, if I subtract one second from each reported round trip sample, the time is very close to that measured for the USB cable. Again this very long delay that I saw is most likely ignorance on my part. I documented the issueand provided the code for both the modified Pico app and Python script in the RaspberryPi forum. Hopefully, someone will explain the delay I am seeing. So, what does this mean?  If my assumption is correct about some hidden 1-second delay and that the delay is removable, the performance between a straight USB cable connection versus a TTL-to-USB converter is equivalent. Therefore, I am going to continue development using the USB cable solution. I also tried MicroPython using the Python std library to get a performance comparison. Outputting using std.write or print works fine, but using std.read seems to confuse the MicroPython REPL. As a result, I am abandoning my hope for a MicroPython solution using a USB cable. I have not tried using the UART with MicroPython. Next, I will write the Telemetrix Python client and Pico server to control a digital input pin, digital output pin, PWM output mode pin, and an analog input pin. The API will be similar to that for the Arduino, which may be viewed here. Once the client is completed, I intend to provide an asyncio version and a Scratch 3 extension for the Pico. Stay tuned! ","categories": ["Raspberry","Pi","Pico"],
        "tags": ["MCU"],
        "url": "http://localhost:4000/bots-in-pieces/raspberry/pi/pico/2021/02/15/pico-adventures-part2.html"
      },{
        "title": "Adventures With The Raspberry Pi Pico - Part 3",
        "excerpt":"First Beta Release I’ve completed the code for the first beta release. This release includes support for:   Digital Output  PWM Output  Digital Input  Analog Input  Auto-detection and connection of a single Pico board.  Loopback (for serial connection debugging)I am in the process of documenting a full User’s Guide, but for thosewho wish to give things a try: To install The Client Library: Linux/macOS: sudo pip3 install telemetrix-rpi-pico Windows: pip install telemetrix-rpi-pico Here is a link to the APINote that not all methods are implemented yet. For the methods that are not implemented, there is the following line on the first line of the method description: NOT YET IMPLEMENTED!!! To Install The Pico Server Application   Download and save the .uf2 file.      Place the Pico in file upload mode:     A. Press and hold the BOOTSEL button while applying power. B. Release the BOOTSEL button.C. In your file explorer, you should see a new folder appear called: RPI-RP2.D. Drag the .uf2 file into this folder to upload the code.         Download, save and uncompress the telemetrix-rpi-pico Github repository.     Open the examples directory and run any of the examples. You maymodify them to suit your needs.I will be implementing i2c support next. Here is a screen-shot of running the digital_input_pullup.py example:  ","categories": ["Raspberry","Pi","Pico"],
        "tags": ["MCU"],
        "url": "http://localhost:4000/bots-in-pieces/raspberry/pi/pico/2021/02/22/pico-adventures-part3.html"
      },{
        "title": "Adventures With The Raspberry Pi Pico - Part 4",
        "excerpt":"Second Beta Release - I2C Support I’ve released the second betaof Telemetrix for the Raspberry Pi Pico.This release incorporates support for monitoring and controlling i2c devices.The Pico supports two i2c ports, and Telemetrix supports both. There are three API methods supporting i2c. The first, set_pin_mode_i2c, allows you to  select which of the two i2c ports the device is attached to and the GPIO pins you assign as SDA and SCL. Note: This method must be called before using the next two i2c methods. The second API method, i2c_write,allows you to write a variable number of bytes to the i2c device on the specifiedi2c port. In addition, you mayspecify if the master retains control of the bus at the end of the transfer. Being able to do so isrequired for some i2c devices. The last API method,i2c_read,provides a way to retrieve data from an i2c device on the specified i2c port. You specify the number of bytes to return, and you may optionally provide an i2c register used for the read. It also allows you to specify if the master retains control of the bus at the end of the transfer.You must also specify a callback function that receives the data reported by the Pico. To summarize, the i2c support is a generalized view for controlling and monitoring i2c devices. In order to support a specific i2c device, the i2c methods listed above are used to implement control andmonitoring as described in the device’s spec sheet. Let’s take a quick look at aworking example provided for interacting with the ADXL345 3-axis accelerometer.     # setup adxl345    # device address = 83    my_board.set_pin_mode_i2c(0, 4, 5)    # time.sleep(.2)    # set up power and control register    my_board.i2c_write(83, [45, 0])    # time.sleep(.2)    my_board.i2c_write(83, [45, 8])    # time.sleep(.2)    # set up the data format register    my_board.i2c_write(83, [49, 8])    # time.sleep(.5)    my_board.i2c_write(83, [49, 3])    # time.sleep(.1)Here we initialize the chip. If you notice, the sleeps are commented out. With Telemetrix, you can run at full speed without having to introduce additional delays. The PICO C-SDK handles things very nicely.     while True:        # read 6 bytes from the data register        try:            my_board.i2c_read(83, 50, 6, the_callback)            # time.sleep(.3)        except (KeyboardInterrupt, RuntimeError):            my_board.shutdown()            sys.exit(0)The code above is the main loop of the program. It requests 6 bytes, which comprisethe upper and lower values for the x, y, and z axes. Consistent with the Telemetrix philosophy, i2c reports are made available to the application via a user-supplied callback function. Callbacks are used because the application is notified as fast as possible of detected data changes on the Pico. def the_callback(data):    \"\"\"    Data is supplied by the library.    :param data: [report_type, i2c port, Device address, device read register,    number of bytes returned, x data pair, y data pair, z data pair    time_stamp]    \"\"\"    time_stamp = data.pop()    date = time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time_stamp))    print(f'Raw Data:  {data}')    print(f'ADXL345 Report On: {date}: ')    print(f'\\t\\ti2c_port={ data[1]} x-pair={data[5]}, '          f'{data[6]}  y-pair={data[7]}, '          f'{data[8]} z-pair={data[9]}, '          f'{data[10]}')    print()The user-provided callback function must supply a single function parameter, called data, in the example above.When Telemetrix calls your callback function, it provides a list describing the report from the Pico. A time-stamp is included for every callback to indicate the time that the event occurred. The elements in the list are described in the API for each callback type. For i2c_read,the last line of the method description contains the description of the items in the callback list.  def i2c_read(self, address, register, number_of_bytes, callback=None, i2c_port=0, no_stop=False)    Read the specified number of bytes from the specified register for the i2c device.    :param address: i2c device address    :param register: i2c register (or None if no register selection is needed)    :param number_of_bytes: number of bytes to be read    :param callback: Required callback function to report i2c data as a result of read command    :param i2c_port: 0 = port 0, 1 = port 1    :param no_stop: If true, master retains control of the bus at the end of the transfer (no Stop is issued), and the next transfer will begin with a Restart rather than a Start.    callback returns a data list: [I2C_READ_REPORT, i2c_port, i2c_device_address, count of data bytes, data bytes, time-stamp]Here is sample output for the ADXL345 example. Both raw and “cooked” data are presented.  Some Thoughts On Working With The Pico C-SDK Versus The Arduino-Core An Arduino-Core version is coming for the RP2040 chip, but no release date has been announced. That is why I am using the RP2040 native SDK. Using an Arduino-Core is a familiar API if you have developed Arduino sketches. That may appear to be an advantage. However, things are not always consistent between implementations for the various processors. One advantage of using an Arduino-Core is that you may be able to reuse an existing Arduino library, such as support for aspecific sensor or actuator. Currently, few support libraries are available for the RP2040, but that is most likely to change over time. It is not clear yet if the Arduino-Core for RP2040 will include PIO support, but I rather doubt it. Assuming I can master programming the PIO, not having access to it would be a major setback. A major advantage of using the RP2040 C-SDK is that its documentation is excellent. Between the documentation and extensive set of Pico examples, understanding the SDK is very straightforward. And if you run into something where you need some additional help, the Raspberry Pi Forum is a wonderful resource. I will admit that there is somewhat of a learning curve, but it is not excessively steep.I have yet to master the syntax of cmake files but have avoided having to do that by using the existing files provided with the examples. All in all, I am pleased with the C-SDK, and when the Arduino-Core finally becomes available, I will probably continue using the C-SDK. Time will tell which becomes the predominant development paradigm. What Comes Next I am currently reading up on the PIO of the RP2040 to provide support for NeoPixels.NeoPixels are the next feature. I know that there are examples in existence that I probably can reuse as-is. Still, I want to understand the “magic” of the PIO processors that are an integral partof the RP2040, all in preparation for implementing my PIO libraries for devices such as the HC-SR04 distance sensor. I am also doing some code cleanup. I am eliminating literal values and replacing them with #defines to make the code easier to read and maintain. Also, buffer storage will be defined as global so that it does not use valuable stack space. Finally, I am splitting the .c file into a .c and .h (header) file.Again this makes things simpler to understand and maintain and is aligned with standard C coding practices. So stay tuned! ","categories": ["Raspberry","Pi","Pico"],
        "tags": ["MCU"],
        "url": "http://localhost:4000/bots-in-pieces/raspberry/pi/pico/2021/03/04/pico-adventures-part4.html"
      },{
        "title": "Adventures With The Raspberry Pi Pico - Part 5",
        "excerpt":"NeoPixel Support Has Been Released I have just released NeoPixel support for the Pico using Telemetrix. Here are the steps to control a NeoPixel strip.       First, you must set the pin mode using theset_pin_mode_neopixelAPI method. Here you specify the GPIO pin number that the NeoPixel strip is controlled with, the number of NeoPixels in your strip (up to a length of 150 is supported), and RGB fill values.NOTE: You must call this method before using any of the following control methods         To set the colors for a given pixel within your strip, use the neo_pixel_set_valuemethod. Here, you specify the pixel number in the strip, the RGB values, and whether you wish to show the changes immediately or wait until theneopixel_showmethod is called.         You can turn all the pixels off by using the neopixel_clearmethod. Here you have the choice to affect the changes immediately or not.         The final method isneopixel_fill,where you may set all the pixels to the same color. Again, you may set the colorsimmediately or wait until you call neopixel_show.   Here is the code for a demo using these methods.  Watch a YouTube video of the demo here. What Is Coming Next I am going to take a break from coding to write the User’s Guide. Once that is complete, I will be working on support for servo motors using a PCC9625 i2c servo motor board similar to the one shown below. ","categories": ["Raspberry","Pi","Pico"],
        "tags": ["MCU"],
        "url": "http://localhost:4000/bots-in-pieces/raspberry/pi/pico/2021/03/13/pico-adventures-part5.html"
      },{
        "title": "Adventures With The Raspberry Pi Pico - Part 6",
        "excerpt":"The User’s Guide has been released for the Telemetrix-Rpi-Pico. I am now moving on to support for Servo motors. I am beginning with attempting to use PWM support. I am not sure if I will need to actually implement a customPIO version or if the PWM support is flexible enough to provide the timing needed. Stay tuned. ","categories": ["Raspberry","Pi","Pico"],
        "tags": ["MCU"],
        "url": "http://localhost:4000/bots-in-pieces/raspberry/pi/pico/2021/03/21/pico-adventures-part6.html"
      },{
        "title": "Adventures With The Raspberry Pi Pico - Part 7",
        "excerpt":"Implementing Servo Support My original intent for servo motor support was to use a PCA9685 basedi2c controller and provide the implementation as an example that userscould expand upon to create a full application. I intend to still provide support for the PCA9685 in the future but as an installable library. Getting the PCA9685 to work with the existing i2c support should be reasonably simple to get going, so I would see if there is some way to create libraries for device support and have the ability to “optionally install” them at compile time. Creating installable library support will take some thought and experimentation, so I am putting thaton the back-burner for the moment. Instead, I am currently experimenting with providing direct PWM support for servo motors. Servo motors require a frequency of 50 Hz. That is to say, that a pulse is generated every 20 ms, sometimes expressed as a period of 20ms. To vary the servo’s position between 0 and 180 degrees, the pulse is set to between 1ms and 2 ms. Modifying the code on this Raspberry Pi Forum posting,I generated the 20ms period without writing any PIO code. However, I have not been able to get the resolution for generating the 180 different pulse lengths for servo control. I will be spending a few days on this, but I am not very hopeful for success on this front. So, what is plan B? I recently read about an Arduino-Core compatible library being released. I am considering reusing the PIO code in the servo library. If I do so, I will give the original author full attribution, as so richly deserved. The original intent of the Telemetrix project was to repurpose Arduino-Core libraries to run on the various Telemetrix supported MCU boards. Using a board-specific Arduino-Core makes porting from one board type to another quick and straightforward. When I started this project, the Arduino-Core was not available, so I decided to use the Pico C-SDK directly. Part of the fun, for me at least, in doing these types of projects is expanding my knowledge, even when it can be slow going and sometimes frustrating. So, why not use the now available Arduino-Core if porting is likely to be quick? The reason is that many of the available Arduino libraries have yet to be ported to the Pico, so if I want to support some additional devices, such as an HC-SRO4 distance sensor, I would have to generate the PIO code anyway. By keeping control over device support, I do not have to contend with libraries that might break future releases. Because I am treading where I have limited expertise, things may progress at a somewhat slower pace. I ask for patience since I believe it will result in a better overall user experience in the end. As always, stay tuned. ","categories": ["Raspberry","Pi","Pico"],
        "tags": ["MCU"],
        "url": "http://localhost:4000/bots-in-pieces/raspberry/pi/pico/2021/03/28/pico-adventures-part7.html"
      },{
        "title": "Adventures With The Raspberry Pi Pico - Part 8",
        "excerpt":"Improved PWM and Servo Support Added PWM Support I have modified the API. The duty-cycle may be specified either as a percentage of 0-99 or in a range of 0-19990 microseconds. Servo Support I was able to implement servo support using standard PICO hardware_pwm SDK methods. When setting a pin mode to servo mode, you can specify the minimum and maximum duty cycle values to allow you to tune where the 0 and 180 positions are for your servo. You may individually tune each servo. What’s Next I am going to try my hand at implementing PIO support for the HC-SR04 Sonar distance sensor. Stay tuned! ","categories": ["Raspberry","Pi","Pico"],
        "tags": ["MCU"],
        "url": "http://localhost:4000/bots-in-pieces/raspberry/pi/pico/2021/04/05/pico-adventures-part8.html"
      },{
        "title": "Adventures With The Raspberry Pi Pico - Part 9 ",
        "excerpt":"Alan In TelemetrixLand Where I fall into a rabbit  hole of my own making  and finally emerge three weeks later with a production release in hand.  Approximately three weeks ago, I started work on supporting two additional sensors for Telemetrix-Rpi-Pico. Namely, the HC-SR04 type SONAR distance sensor and the DHT Humidity/Temperature sensor. Since I wanted to understand more about using the PIO features of the RP2040, I thought the HC-SR04 would be a good candidate for controlling and monitoring the device while I learn about coding the PIO. However, before I started to tackle the PIO code, I came across aPIO solution on GitHub, and much to my pleasure, it worked excellently. About That Rabbit Hole The discovered PIO solution requires using separate echo and trigger pins. I wanted to modify the code to work using a single pin connected to both echo and trigger. So I set about trying to figure out how to change GPIO pin direction using PIO code. To help monitor things, I connected a USB logic analyzer to the sensor using the original unmodified code.I was able to see the activation of the trigger pin and the subsequent echo pin outputting varying periods depending upon the distance measured. So far, so good.However, when I tried using a single pin and reversing direction, the trigger pulse was never generated. Typically, when I try working with something that I do not have a great deal of familiarity with, I model a solution using a tried and true method. In this case, it would be simply toggling the pin to generate a trigger pulse, changing GPIO pin direction, and then observing the generated echo. However, I violated my own  tried and true development rules and jumped into PIO coding. After spending nearly a week playing with PIO code and continuously failing to see a trigger pulse, I reverted to  the tried and true. Guess what? My failure had nothing to do with PIO. To test, I used a US-100 device which is a 3-volt compatible version of the HC-SR04. When testing with simple GPIO pulses, it was clear the device itself was the cause of my issue and had nothing to do with my understanding of PIO coding. Perhaps if I used a pull-up resistor, I could’ve gotten things to work. However, since I want this library to be simple to use in the classroom without any additional components, I decided to abandon my one pin solution and reverted to using separate trigger and echo pins., There was an additional complication that I needed to solve before integrating the PIO solution into my code.The original code was written in C++. Using CMAKE and integrating C and C++ files in a single project does not seem to be a trivial effort, so I needed to take the time to convert the original HC-SR04 code to C. Not a huge effort, but it did eat up some additional time. What was the cost for all this stubbornness? Close to 2 weeks with very little to show for my wasted efforts. The good news? HC-SR04 is now in place. Adding DHT Support I decided to use this Pico example to support the device. I compiled the code, hooked up my trusty DHT22, and it didn’t work. I have used the same device for other projects and never had to use a pull-up resistor. Nevertheless, Iadded the resistor, and the same result - a no-go. Now I tried a DHT11, and the same result. I compared the code with an Arduino library, and it was very similar. There were some magic values in the code that I did not fully understand. So after 2 or 3 daysof head-scratching, I checked the GitHub repository against the open issues. Low and behold, there was an open issue matching mine. One of the user’s solutions was to change one of the magic values, and when I tried that solution, all started working without connecting a pull-up resistor.  The author ofthe original code, for some reason, has not incorporated this fix even though several users, including myself, verified that the solution worked. Supporting The Long Delays Required By DHT Devices DHT devices require about 2 seconds to collect data to return to the user after being commanded to get a reading. The original code had incorporated a two-second sleep. Using a delay works fine for the example, but Telemetrix-Rpi-Pico can’t afford to block 2 seconds since it continually monitors other inputs. In addition, I wanted to support more than one DHT device. When working with Arduino Firmata, I had to devise a rather complex strategy not to block the main loop yet wait for two seconds to pass. I could have implemented a similar scheme for the Pico, but the Pico SDK incorporates some rather excellent timer/alarm support.  With just a few lines of code and none of the Firmata complexity, I was able to perform a non-blocking wait using a  repeating timer. Out Of The Rabbit Hole - Some Final Thoughts So, now version 1.0 of Telemetrix-Rpi-Pico is complete, I want to reflect on whether using the C SDK was worth doing or should I have gone to an Arduino compatible core library  recently released or an unofficial version of a Pico  Arduino core. Sticking With The C SDK I decided to stay with the C SDK. It offers some features that the Arduino core does not, namely direct PIO support and features such as the repeating timer. A potential advantage of the Arduino core over the C SDK is the possibility of reusing Arduino libraries, but there is a 50/50 chance the library may not work with the RP2040.  Also, there is the familiarity of the Arduino API. Mixing C and C++ code within the Arduino ecosystem is easily done, so that is an advantage. However,I intend to solve the mystery of doing something similar for the CMAKE world of the C SDK soon. All in all, I am very impressed with the C SDK and the overall quality of its documentation. Also, the fact I can easily use the SDK with either VS Code or CLion (my IDE of choice) is  a big plus. I am not a fan of the Arduino IDE. What’s Next? I will implement a Python asyncio version of the client and then adapt that into aOneGPIO Gatewayfor the Pico. In addition, I still want to  create an i2c example for the PCA9685 servo controller. As always, stay tuned! ","categories": ["Raspberry","Pi","Pico"],
        "tags": ["MCU"],
        "url": "http://localhost:4000/bots-in-pieces/raspberry/pi/pico/2021/04/23/pico-adventures-part9.html"
      },{
        "title": "First Impressions Of The Arduino Nano RP2040 Connect",
        "excerpt":" I just received my Arduino Connect RP2040 board, and I am sorry to say that getting this thing up and running has been somewhat of a nightmare. It kind of reminds me of using the now-discontinued Arduino Yun Using the Arduino IDE 1.8.15, the quick-install instructions tell you to install the Arduino Mbed OS Nano Boards library using the boards’ manager. Simple enough. I then selected the Arduino Nano RP2040 Connect from the boards’ selection menu and set the correct COM port. Then I loaded the blink script and did a test compile. So far, all is well. However, when I tried to upload, I got a non-descript loading error message. I turned on all warnings and errors in the IDE, which did not offer any additional clues. So, I turned to the Arduino forum to find a solution. I found several postings about first putting the board into program mode by pressing the on-board switch two times. I did so but did it help? Absolutely not. So I searched the forum again and found a posting that said that a post-install script needed to be run in Arduino IDE. This shell script is: ~/.arduino15/packages/arduino/hardware/mbed_rp2040/1.5.2/post_install.sh So when I went to run this script, it was not there. It turns out you need to load yet another (unmentioned) library, that is, Arduino Mbed OS RP2040 Boards. Again, not mentioned in the documentation. Once this board’s library is loaded, you can then run the post-install script. Finally, I could upload the blink example script. Lots of fun! Now on to try out WiFi. Wish me luck! ","categories": ["Arduino","RP2040"],
        "tags": ["MCU"],
        "url": "http://localhost:4000/bots-in-pieces/arduino/rp2040/2021/06/22/rp2040-connect-first-impressions.html"
      },{
        "title": "Second Impressions Of The Arduino Nano RP2040 Connect",
        "excerpt":" I was really bummed about my initial interaction with the Arduino Nano RP2040 Connect. However, once over the initial hurdle of setting things up for development, I was able to port Telemetrix to this board and blinked the board LED all within about an hour. I am indeed impressed and thrilled to say that Arduino did not repeat the Yun disaster. Way to go, Arduino! I had to remove DHT support since the DHTStable library does not seem to work for the RP2040. I will be testing all the0ther Telemetrix interfaces and hope to publish a fullyworking client and server for this board soon. ","categories": ["Arduino","RP2040"],
        "tags": ["MCU"],
        "url": "http://localhost:4000/bots-in-pieces/arduino/rp2040/2021/06/22/rp2040-connect-second-impressions.html"
      }]
