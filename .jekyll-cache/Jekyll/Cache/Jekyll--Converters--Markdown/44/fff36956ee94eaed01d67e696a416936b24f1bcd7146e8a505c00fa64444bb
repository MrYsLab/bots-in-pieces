I"—ö<p><img src="/bots-in-pieces/images/p2pa/playing.png" alt="" /></p>

<p>I recently read a 
<a href="https://realpython.com/arcade-python-game-framework/">RealPython article</a>
 about Paul Cravenâ€™s <a href="https://arcade.academy/"><strong><em>Arcade gaming library</em></strong></a> for Python.
After examining  the <em>Arcade</em> examples,
I was impressed by <em>Arcadeâ€™s</em> consistency and ease of use.</p>

<blockquote>
  <p>Want to quickly get up to speed with <em>Arcade</em>? Check out this
<a href="https://www.youtube.com/watch?v=2qP1M1Nf__w">12 part YouTube <em>Arcade</em> tutorial.</a></p>
</blockquote>

<p>The <em>Arcade</em> library was designed to create 2D games to be run on a single computer, and it accomplishes
that goal brilliantly. 
That being said, having run an after-school Scratch club for a local middle school, one of the things my
students always wished for was the ability to create multi-player networked games. Sadly, Scratch does not support this, and the students were
 left disappointed. Thinking of my students, I decided to see if I could use <em>Arcade</em> to create
multi-player games. And thus, this <em>multi-player proof of concept</em> began.</p>

<p>In this posting, I will discuss how to create a multi-player game using
the Python <em>Arcade</em> gaming library in conjunction with the Python Banyan framework.
Banyan augments <em>Arcade</em> by providing the networking and messaging support required for
multi-player games.</p>

<p>What will be covered:</p>

<ul>
  <li>A short discussion of multi-player software architectures.</li>
  <li>The self-imposed requirements and goals of the proof-of-concept presented in this posting.</li>
  <li>How I selected a game to demonstrate the concepts.</li>
  <li>How to install and run the demo code.</li>
  <li>Getting into the details:
    <ul>
      <li>A quick introduction to Python Banyan.</li>
      <li>Looking at how the code was assembled.</li>
    </ul>
  </li>
</ul>

<h1 id="multiplayer-support-schemes---clientserver-vs-peer-to-peer">Multiplayer Support Schemes - Client/Server vs. Peer To Peer</h1>

<p>Multiplayer games generally are implemented using one of 2 schemes, client/server being one, and peer to peer(p2p)
being the other.</p>

<p><img src="/bots-in-pieces/images/p2pa/client_server.png" alt="" /></p>

<p>With the client/server model, the players connect to a central server. The server receives the individual playerâ€™s
interaction events (keyboard presses, mouse moves, joystick motion, etc.), updates the game based
on the events received, and then generates and sends
screen updates to the individual players.</p>

<h3 id="pros">Pros</h3>
<ul>
  <li>Relatively easy to implement.</li>
  <li>Cheating is averted since the server monitors all events</li>
</ul>

<h3 id="cons">Cons</h3>

<ul>
  <li>It requires a separate server or server process.
<br /><br /></li>
</ul>

<p><img src="/bots-in-pieces/images/p2pa/p2p.png" alt="" /></p>

<p>With peer to peer (p2p), there is no central server. As each player generates screen events, the local game instance
sends screen update requests to each of the players.</p>

<h3 id="pros-1">Pros</h3>

<ul>
  <li>No central server required. Players communicate directly with each other.</li>
</ul>

<h3 id="cons-1">Cons</h3>

<ul>
  <li>More difficult to implement than the client/server model.</li>
  <li>Potential for game cheating since no central authority is in control.</li>
</ul>

<h1 id="goals-and-requirements-of-the-project">Goals and Requirements Of The Project</h1>

<p>Taking the road less traveled, I decided to explore using the p2p model. Here
are the requirements I set for myself:</p>

<ul>
  <li>The game is intended to be confined to a single LAN. Restricting 
support to within a single LAN avoids security 
issues and simplifies routing.</li>
  <li>The game is to consist of a single Python script run as two separate processes on a single computer, or
on two different computers.</li>
  <li>Player role selection is accomplished using a command-line option.</li>
  <li>Linux, macOS, and Windows are to be supported.</li>
  <li>As each player generates game events, screen updates must be fast and in sync with the other player.</li>
  <li>Compatible with Python 3.7 and above.</li>
</ul>

<h1 id="the-proof-of-concept">The Proof Of Concept</h1>

<h2 id="finding-a-game-candidate">Finding A Game Candidate</h2>

<p>Realizing that I am not the best at designing computer games, I wanted to find an existing game
that I could modify to illustrate my proof of concept ideas. Turning to the <em>Arcade</em> examples, I chose
the
<a href="https://arcade.academy/examples/sprite_collect_coins_move_bouncing.html#sprite-collect-coins-move-bouncing">Collect Coins that are Bouncing example</a></p>

<h3 id="but-isnt-that-a-one-player-game">But Isnâ€™t That A One-Player Game?</h3>

<p><img src="/bots-in-pieces/images/p2pa/orig_game.png" alt="" /></p>

<p>When first looking at the game, it appears that there is only one player. The goal of the game is
for the player, using the mouse, 
to collect all of the randomly bouncing coins. When the female sprite touches a coin, the coin is removed from play,
 and the score is incremented by 1.</p>

<p>This looks like a single-player game, but what if we viewed the game in a slightly different way. What if the female sprite, which we
call player 1, was controlled on one computer, and the coins and their random motion on another computer.
We can then consider the coins as player 0. In this way, we have a two-player game with 
one player, player 1 
being human-controlled, and the other player, player 0, being computer-controlled.</p>

<p>Each of the players would need to have a copy of the mouse-controlled player sprite, the 50 coin sprites,
and game score text. Each player is responsible for updating their own domain and notifying the peer of these
updates. Both playerâ€™s screens need to be updated in unison in near real-time!</p>

<h1 id="a-video-demo-of-the-p2p-game">A Video Demo Of The P2P Game</h1>

<p>Before learning how all this works, it may be beneficial to see an actual demo of the 
proof of concept. The demo was run on a Linux computer with an AMD 3700x processor for one of the peers,
and on a Windows 10 laptop using an Intel i7-6600q processor for the second peer. Both computers
are running RealVNC to allow for screen-capture of both machines.</p>

<p>The left-hand side of the screen is the Linux computer, and it controls the coins. The
right-hand side is the Windows computer, and it controls the female collection sprite.</p>

<p>NOTE: Swapping the players on the computers <em>does not</em> affect performance.</p>

<h2 id="what-you-will-see">What You Will See</h2>

<p>When each instance of the game starts, it generates its own copy of the female collection sprite
and the 50 coin sprites. The collection sprite is initially placed at the same screen location for
both players. The coins for each player, are initially placed randomly on each screen. 
Therefore at this time, the coin placements differ for each of the players. This is shown below.</p>

<p><img src="/bots-in-pieces/images/p2pa/start1.png" alt="" /></p>

<p>When the left mouse button is clicked, the coins will go into motion. Notice that
once that happens, the positions of the coins are aligned on both screens.</p>

<p>After the right mouse button is clicked to enable coin collection when the female sprite touches a coin sprite, the
coin is removed, and the score is increased by one.</p>

<p>To view a screen capture of the demo, click on the screen-shot below.</p>

<p><a href="https://www.youtube.com/watch?v=xC_4D0Bod_4&amp;feature=youtu.be"><img src="http://i3.ytimg.com/vi/xC_4D0Bod_4/maxresdefault.jpg" alt="Video Title" /></a></p>

<h1 id="running-the-demo-for-yourself">Running The Demo For Yourself</h1>

<h2 id="install-the-demo">Install The Demo</h2>

<p>To install the code, open a terminal window. For Linux and macOS type:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>pip3 <span class="nb">install </span>p2p-arcade
</code></pre></div></div>

<p>For Windows type:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>p2p-arcade
</code></pre></div></div>

<p>In addition to all the necessary libraries, a command-line executable, <em>p2pa</em> is installed.</p>

<p>If you wish to run the demo using two computers, repeat the steps above on the second computer.</p>

<blockquote>
  <p>IMPORTANT NOTE: <em>Arcade</em> does not run on a Raspberry Pi because it requires OpenGL 3.3, which
is not yet available for the RPi.</p>
</blockquote>

<h2 id="running-the-demo-on-one-computer">Running The Demo On One Computer</h2>

<p>If you wish to try the demo on a single computer, open a terminal window and type:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p2pa
</code></pre></div></div>

<p>This will start the player 0 window.</p>

<p>Next, open another window, but this time type:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p2pa <span class="nt">-p</span> 1
</code></pre></div></div>

<p>The -p command-line option specifies that this instance
 is to be run as player 1.</p>

<p>Now click the left mouse button to start the coins in motion and then click the 
right mouse button and collect the coins.</p>

<h2 id="running-the-demo-on-two-computers">Running The Demo On Two Computers</h2>

<p>On the first computer, open a terminal window and type:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p2pa
</code></pre></div></div>

<p>In the terminal window you will see a Python Banyan informational heading 
that looks similar to that below:</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">************************************************************</span>
Arcade p2p player0 using Back Plane IP address: 192.168.2.191
Subscriber Port <span class="o">=</span> 43125
Publisher  Port <span class="o">=</span> 43124
Loop Time <span class="o">=</span> 0.0001 seconds
<span class="k">************************************************************</span>
</code></pre></div></div>

<p>The value for the IP address of your computer will most likely be different
than the one shown above, so jot down the <em>Back Plane IP address</em> displayed.</p>

<p>Now on the second computer, open a terminal window type in a command similar to the following,
substituting the IP address you jotted down.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>p2pa <span class="nt">-p</span> 1 <span class="nt">-b</span> 192.168.2.191
</code></pre></div></div>

<p>The -p command-line option specifies this instance as a player 1 instance, and the 
-b option specifies the IP address of the active Banyan Backplane.</p>

<p>The Banyan Backplane routes all of the messages for you without having to set up
any routing tables.</p>

<blockquote>
  <p>When you started player 0 on the first computer, the Backplane was automatically invoked. 
The -b command-line option is used to connect both peers to a common Backplane.</p>
</blockquote>

<p>Click the left mouse button, followed by a click of the right mouse button to start collecting coins.</p>

<h1 id="so-how-does-this-all-work">So How Does This All Work?</h1>

<p>While reading this section, if you wish to view the source code for the original game example, click on
 <a href="https://github.com/pvcraven/arcade/blob/master/arcade/examples/sprite_collect_coins_move_bouncing.py">this link.</a>
To view the source code for p2p-arcade.py<br />
<a href="https://github.com/MrYsLab/p2p-arcade/blob/master/p2p_arcade/p2p_arcade.py">click here.</a></p>

<h2 id="defining-and-implementing-game-behavior-in-arcade">Defining And Implementing Game Behavior In Arcade</h2>
<p>If youâ€™ve read the RealPython article and/or have watched the videos, you already know that the 
<strong>arcade.Window</strong> class provides several methods to capture <em>hardware events</em>, such as mouse or
keyboard interaction.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">on_mouse_motion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">):</span>
        <span class="s">""" Handle Mouse Motion """</span>

        <span class="c1"># Move the center of the player sprite to match the mouse x, y
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">player_sprite</span><span class="p">.</span><span class="n">center_x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">player_sprite</span><span class="p">.</span><span class="n">center_y</span> <span class="o">=</span> <span class="n">y</span>
</code></pre></div></div>

<p>The <strong>arcade.Window</strong> class also has an <strong>on_update</strong> method allowing you to control screen updates 
with each iteration of the event-loop. This is shown below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">def</span> <span class="nf">on_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta_time</span><span class="p">):</span>
        <span class="s">""" Movement and game logic """</span>

        <span class="c1"># Call update on all sprites (The sprites don't do much in this
</span>        <span class="c1"># example though.)
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">all_sprites_list</span><span class="p">.</span><span class="n">update</span><span class="p">()</span>

        <span class="c1"># Generate a list of all sprites that collided with the player.
</span>        <span class="n">hit_list</span> <span class="o">=</span> <span class="n">arcade</span><span class="p">.</span><span class="n">check_for_collision_with_list</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">player_sprite</span><span class="p">,</span>
                                                        <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">)</span>

        <span class="c1"># Loop through each colliding sprite, remove it, and add to the score.
</span>        <span class="k">for</span> <span class="n">coin</span> <span class="ow">in</span> <span class="n">hit_list</span><span class="p">:</span>
            <span class="n">coin</span><span class="p">.</span><span class="n">remove_from_sprite_lists</span><span class="p">()</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">score</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div></div>
<p>The <em>on_update</em> method calls the  <em>update</em> method within the 
<em>all_sprites_list</em>. The all_sprites_list iterates through its list of sprites
calling each spriteâ€™s <em>update</em> method.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Coin</span><span class="p">(</span><span class="n">arcade</span><span class="p">.</span><span class="n">Sprite</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">sprite_scaling</span><span class="p">):</span>

        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">sprite_scaling</span><span class="p">)</span>

        <span class="bp">self</span><span class="p">.</span><span class="n">change_x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">change_y</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># Move the coin
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">center_x</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">.</span><span class="n">change_x</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">center_y</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">.</span><span class="n">change_y</span>

        <span class="c1"># If we are out-of-bounds, then 'bounce'
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">left</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">change_x</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">right</span> <span class="o">&gt;</span> <span class="n">SCREEN_WIDTH</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">change_x</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">bottom</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">change_y</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">top</span> <span class="o">&gt;</span> <span class="n">SCREEN_HEIGHT</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">change_y</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div></div>

<p>Hopefully, I did not lose you with the discussion of nested-updates. But in case I did,
here is a diagram to illustrate <em>update</em> sequencing.</p>

<p><img src="/bots-in-pieces/images/p2pa/updates1.png" alt="" /></p>

<h2 id="adding-multiplayer-functionality">Adding Multiplayer Functionality</h2>
<p>To implement a multi-player game, we need a way for each player to
capture both hardware events and screen update information. Each player then must notify its
 peer of these changes.</p>

<p>To provide a vehicle for player update notifications, we 
will be using the <a href="https://mryslab.github.io/python_banyan/#">Python Banyan Framework.</a></p>

<h2 id="understanding-the-modified-code">Understanding The Modified Code</h2>

<p>So to understand the p2p_arcade.py code, we will:</p>

<ul>
  <li>Discuss the basics of Python Banyan</li>
  <li>Show how the MyGame class is extended to incorporate Python Banyan and the Python threading class.
    <ul>
      <li>Threading is used to provide concurrency between the <em>Arcade</em> and Banyan event loops.</li>
    </ul>
  </li>
  <li>Explain how the data is captured.</li>
  <li>Show how the captured data is sent, received, and processed by both players.</li>
</ul>

<h2 id="what-is-python-banyan">What Is Python Banyan?</h2>

<p>The <a href="https://mryslab.github.io/python_banyan/">Python Banyan Framework</a>
 is a lightweight, reactive framework used to create flexible, 
non-blocking, event-driven, asynchronous applications. Quite a mouthful,
but it very easy to use and has a straightforward <a href="https://htmlpreview.github.io/?https://raw.githubusercontent.com/MrYsLab/python_banyan/master/html/python_banyan/banyan_base/banyan_base.html">API.</a></p>

<p>Banyan uses a publish/subscribe (pub/sub) messaging model. We will discuss pub/sub in 
 more detail in the sections that follow.</p>

<h3 id="for-those-familiar-with-mqtt-pubsub">For Those Familiar With MQTT Pub/Sub</h3>
<p>Python Banyan, in some ways, is similar to 
MQTT but has much better performance.</p>

<p>Similar to MQTTâ€™s broker, Python Banyan uses an entity called the <strong><em>Backplane</em></strong>. For the p2p_arcade
demo, the <em>Backplane</em> is automatically started for you.</p>

<h3 id="banyan-components">Banyan Components</h3>

<p>Banyan entities, known as <em>Banyan Components</em>, communicate with each other by 
connecting to a common Banyan Backplane. The Backplane is a central point of contact for all the
Banyan Components. It simplifies message routing in that all Banyan Components use  shared
IP Addresses and IP ports for publishing and subscribing to messages.</p>

<p>A Banyan Component is an independent process but is a member of a set of Components that 
comprise a <em>Banyan Application</em>.</p>

<h3 id="banyan-applications">Banyan Applications</h3>
<p>The player 0 instance of p2pa runs as one Banyan Component, and the
player 1 instance of p2pa is run as a second Banyan Component. Together, both components create
a single Banyan Application communicating with one another using LAN connected messaging.</p>

<p>If the Banyan Components reside on a single computer, they will all automatically connect
to the local Backplane. If the Banyan Application is distributed across
multiple computers, both Banyan Components still need to share a single Backplane.</p>

<h3 id="banyan-distributed-applications">Banyan Distributed Applications</h3>

<p>Banyan Components may be distributed across multiple computers without
any code changes.
The only difference between a distributed and non-distributed Banyan Application is that
we need to point one or both of the Banyan Components to a common Banyan Backplane.</p>

<p>If you recall, when running the p2pa demo across two machines, the -b command-line option
to connect player 1 to connect to the same Backplane that player 0 was using.</p>

<h3 id="pubsub">Pub/Sub</h3>

<p><img src="/bots-in-pieces/images/p2pa/pub_sub.png" alt="" /></p>

<h4 id="publishing-a-message">Publishing A Message</h4>

<p>With the pub/sub model, a publishing entity gathers data, forms a message containing the data, and then
publishes the message to the network. In addition to the data, each message is associated with a message topic
at the time of the publication.</p>

<p>Messages are created as a Python dictionary. So, for example, letâ€™s say we wish to publish a message
containing the current time containing hours, minutes, and seconds. Here is one way of doing this.</p>

<p>To get the current time, we first need to <strong><em>import datetime</em></strong>, then we call <strong><em>datetime.datetime.now()</em></strong> to
retrieve the current time.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">datetime</span>

<span class="n">now</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">.</span><span class="n">datetime</span><span class="p">.</span><span class="n">now</span><span class="p">()</span>
</code></pre></div></div>

<p>Using the results in <em>now</em>, letâ€™s build a Banyan message.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">payload</span> <span class="o">=</span> <span class="p">{</span><span class="s">'hour'</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">hour</span><span class="p">,</span> <span class="s">'minute'</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">minute</span><span class="p">,</span> <span class="s">'seconds'</span> <span class="o">=</span> <span class="n">now</span><span class="p">.</span><span class="n">seconds</span><span class="p">}</span>
</code></pre></div></div>

<p>To publish the message we need to call the Banyan method <strong><em>publish_payload</em></strong>.</p>

<p>The publish_payload method takes two parameters. The first is the payload, and the second is a message topic.
For this example, we will set the topic to â€˜current_timeâ€™.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="bp">self</span><span class="p">.</span><span class="n">publish_payload</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="s">'current_time'</span><span class="p">)</span>
</code></pre></div></div>

<p>Python Banyan automatically encodes the message for transmission and takes care of all the TCP/IP details
for you.</p>

<h4 id="subscribing-to-receive-messages">Subscribing To Receive Messages</h4>
<p>A subscribing entity may elect to receive all messages for one or several topics of interest.
 Continuing with our example,
to receive messages with the <em>â€˜current_timeâ€™</em> topic, 
we need to subscribe to the <em>â€˜current_timeâ€™</em> topic. To set a subscription topic,
the <strong><em>set_subscriber_topic</em></strong> method is called, passing in the topic string.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="bp">self</span><span class="p">.</span><span class="n">set_subscriber_topic</span><span class="p">(</span><span class="s">'current_time'</span><span class="p">)</span>
</code></pre></div></div>

<p>A separate call to set_subcriber_topic is used for each topic of interest.</p>

<p>Next, we need to start the Banyan <em>receive-loop</em>. The receive_loop waits to receive
any messages with topics that match the topics we have elected to receive.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="bp">self</span><span class="p">.</span><span class="n">receive_loop</span><span class="p">()</span>
</code></pre></div></div>
<p>Because the <em>receive_loop</em> must run continuously without blocking, it will be run
in a separate thread from the <em>Arcade</em> event-loop.</p>

<h4 id="processing-incoming-messages">Processing Incoming Messages</h4>

<p>When the Banyan receive_loop receives a message, it automatically calls a Banyan method
 called <strong><em>incoming_message_processing()</em></strong>.</p>

<p>This method <em>must be</em> overridden for the message to be processed.</p>

<p>When Banyan calls <em>incoming_message_processing</em>, it passes in two parameters. The first is the 
message topic string, and the second is the decoded message payload.</p>

<p>We can use the message topic to de-reference messages from one another. We can
then do whatever we need to properly process the message.</p>

<h2 id="extending-and-modifying-mygame-for-multi-player-functionality">Extending And Modifying MyGame For Multi-Player Functionality</h2>

<p>To add Python Banyan behaviors as well as multi-threading behaviors to 
the <strong>MyGame</strong> class, we redefine it as:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MyGame</span><span class="p">(</span><span class="n">arcade</span><span class="p">.</span><span class="n">Window</span><span class="p">,</span> <span class="n">threading</span><span class="p">.</span><span class="n">Thread</span><span class="p">,</span> <span class="n">BanyanBase</span><span class="p">):</span>
</code></pre></div></div>

<p>As with single inheritance, we need to initialize all of the parent
classes by calling the <em>__init</em>__ method for each of the parent classes.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arcade</span><span class="p">.</span><span class="n">Window</span><span class="p">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SCREEN_WIDTH</span><span class="p">,</span> <span class="n">SCREEN_HEIGHT</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>

<span class="n">threading</span><span class="p">.</span><span class="n">Thread</span><span class="p">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="n">BanyanBase</span><span class="p">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">back_plane_ip_address</span><span class="o">=</span><span class="n">back_plane_ip_address</span><span class="p">,</span>
                    <span class="n">process_name</span><span class="o">=</span><span class="n">process_name</span><span class="p">,</span> <span class="n">loop_time</span><span class="o">=</span><span class="p">.</span><span class="mi">0001</span><span class="p">)</span>
        <span class="c1"># Initialize the python-banyan base class parent.
</span>        <span class="c1">#
</span>        <span class="c1"># If the backplane_ip_address is == None, then the local IP
</span>        <span class="c1"># address is used.
</span>        <span class="c1">#
</span>        <span class="c1"># The process name is just informational for the Banyan header
</span>        <span class="c1"># printed on the console.
</span>        <span class="c1">#
</span>        <span class="c1"># The loop_time the amount of idle time in seconds for the
</span>        <span class="c1"># banyan receive_loop to wait to check for the next message
</span>        <span class="c1"># available in its queue.
</span></code></pre></div></div>

<h2 id="the-modifying-the-coin-class">The Modifying The Coin Class</h2>

<p>For the Coin class, we add an attribute, <em>my_index</em>, and provide getter and setter properties for the
attribute. We also remove the original code contained in the <em>update</em> method.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Coin</span><span class="p">(</span><span class="n">arcade</span><span class="p">.</span><span class="n">Sprite</span><span class="p">):</span>
    <span class="s">"""
    Coin sprite definition
    """</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">sprite_scaling</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">sprite_scaling</span><span class="p">)</span>

        <span class="bp">self</span><span class="p">.</span><span class="n">change_x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">change_y</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Assign an index number to each coin
</span>        <span class="c1"># so that we can track coins across game instances.
</span>        <span class="c1"># We establish this as a property in the methods below.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_my_index</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">my_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_my_index</span>

    <span class="o">@</span><span class="n">my_index</span><span class="p">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">my_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_my_index</span> <span class="o">=</span> <span class="n">index</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        Updates will be controlled in the second thread
        using python-banyan.
        """</span>
        <span class="k">return</span>
</code></pre></div></div>

<h3 id="why-do-we-need-my_index">Why do we need my_index?</h3>
<p>Each <em>player</em> is a process running in its own memory space. Each <em>player process</em> has its own copy of
the coin_list. When we need to remove a coin from the list for
both players, we need a memory independent way of identifying which coin to remove. Coins with matching
my_index values represent coins having the same positions on both screens. By using the my_index value to identify
a specific coin to remove, both screens will appear to remove the same coin.</p>

<h2 id="continuing-with-modifications-to-the-mygame-class">Continuing With Modifications To The MyGame Class</h2>

<h3 id="modifications-to-setup">Modifications To setup</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">def</span> <span class="nf">setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        Initialize the game
        """</span>
        <span class="c1"># Sprite lists
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">all_sprites_list</span> <span class="o">=</span> <span class="n">arcade</span><span class="p">.</span><span class="n">SpriteList</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span> <span class="o">=</span> <span class="n">arcade</span><span class="p">.</span><span class="n">SpriteList</span><span class="p">()</span>

        <span class="c1"># Set up the player 1
</span>        <span class="c1"># Character image from kenney.nl
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">player_sprite</span> <span class="o">=</span> <span class="n">arcade</span><span class="p">.</span><span class="n">Sprite</span><span class="p">(</span><span class="s">":resources:images/animated_characters/female_person/femalePerson_idle.png"</span><span class="p">,</span>
                                           <span class="n">SPRITE_SCALING_PLAYER</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">player_sprite</span><span class="p">.</span><span class="n">center_x</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">player_sprite</span><span class="p">.</span><span class="n">center_y</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">all_sprites_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">player_sprite</span><span class="p">)</span>

        <span class="c1"># Create the coins which constitute player 2
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">COIN_COUNT</span><span class="p">):</span>
            <span class="c1"># Create the coin instance
</span>            <span class="c1"># Coin image from kenney.nl
</span>            <span class="n">coin</span> <span class="o">=</span> <span class="n">Coin</span><span class="p">(</span><span class="s">":resources:images/items/coinGold.png"</span><span class="p">,</span> <span class="n">SPRITE_SCALING_COIN</span><span class="p">)</span>

            <span class="c1"># Position the coin
</span>            <span class="n">coin</span><span class="p">.</span><span class="n">center_x</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="n">SCREEN_WIDTH</span><span class="p">)</span>
            <span class="n">coin</span><span class="p">.</span><span class="n">center_y</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="n">SCREEN_HEIGHT</span><span class="p">)</span>
            <span class="n">coin</span><span class="p">.</span><span class="n">change_x</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="n">coin</span><span class="p">.</span><span class="n">change_y</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            
            <span class="c1"># add the index number to each coin
</span>            <span class="n">coin</span><span class="p">.</span><span class="n">my_index</span> <span class="o">=</span> <span class="n">i</span>

            <span class="c1"># Add the coin to the lists
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">all_sprites_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">coin</span><span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">coin</span><span class="p">)</span>
</code></pre></div></div>
<p>When creating the coins, we set each coinâ€™s my_index value. Also, we moved score initialization
from the __init__ method to here.</p>

<h3 id="modifications-to-on_mouse_motion">Modifications To on_mouse_motion</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">on_mouse_motion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">):</span>
        <span class="s">"""
        Mouse motion detection and handling
        :param x: x position
        :param y: y position
        :param dx: change in x
        :param dy: change in y
        """</span>
        <span class="c1"># Move the center of the player sprite to match the mouse x, y
</span>        <span class="c1"># by publishing the position as a banyan message.
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">player</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">payload</span> <span class="o">=</span> <span class="p">{</span><span class="s">'p1_x'</span><span class="p">:</span> <span class="n">x</span><span class="p">,</span> <span class="s">'p1_y'</span><span class="p">:</span> <span class="n">y</span><span class="p">}</span>
            <span class="n">topic</span> <span class="o">=</span> <span class="s">'p1_move'</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">publish_payload</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="n">topic</span><span class="p">)</span>
</code></pre></div></div>
<p>Here we remove updating the position of the female sprite directly. Player 1 captures the current x and y
positions of the mouse, assembles a Banyan message containing those values, and then publishes the message
with a topic of â€˜p1_moveâ€™ to indicate player 1 moved on the screen.</p>

<p>Both players will update the player position on their respective screens when the message is received and
processed. This will be discussed a little further down.</p>

<h3 id="adding-code-to-process-mouse-button-presses">Adding Code To Process Mouse Button Presses</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">on_mouse_press</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">button</span><span class="p">,</span> <span class="n">modifiers</span><span class="p">):</span>
        <span class="c1"># start the coins in motion
</span>        <span class="k">if</span> <span class="n">button</span> <span class="o">==</span> <span class="n">arcade</span><span class="p">.</span><span class="n">MOUSE_BUTTON_LEFT</span><span class="p">:</span>
            <span class="n">payload</span> <span class="o">=</span> <span class="p">{</span><span class="s">'go'</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">publish_payload</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="s">'enable_coins'</span><span class="p">)</span>

        <span class="c1"># start collision detection if we've started the coins in motion
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">go</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">button</span> <span class="o">==</span> <span class="n">arcade</span><span class="p">.</span><span class="n">MOUSE_BUTTON_RIGHT</span><span class="p">:</span>
                <span class="c1"># self.run_collision_detection = True
</span>                <span class="n">payload</span> <span class="o">=</span> <span class="p">{</span><span class="s">'collision'</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">publish_payload</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="s">'enable_collisions'</span><span class="p">)</span>
</code></pre></div></div>
<p>Here we detect left or right mouse button presses. An appropriate Banyan
message is assembled for each press type and published.</p>

<p>When the <em>enable_coins</em> message
is received in the Banyan <em>receive_loop</em> thread, the <em>go</em> attribute is set to True, enabling
coin motion.</p>

<p>When the <em>enable_collisions</em> message is received in the Banyan <em>receive_loop,</em> the <em>run_collision_detection</em>
is set to True, enabling collision detection.</p>

<h3 id="modifying-arcadewindowon_update">Modifying arcade.Window.on_update</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">on_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta_time</span><span class="p">):</span>
        <span class="s">"""
        Update the sprites.
        :param delta_time:
        """</span>

        <span class="c1"># update the female collection sprite.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">all_sprites_list</span><span class="p">.</span><span class="n">update</span><span class="p">()</span>

        <span class="c1"># If we started the coins in motion, and this is the "coin" player,
</span>        <span class="c1"># gather all the current positions of the coins in the coin_list.
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">go</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">player</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># build a list of all the coin positions using a list comprehension.
</span>                <span class="c1"># publish this list with the updated coin positions.
</span>                <span class="k">with</span> <span class="bp">self</span><span class="p">.</span><span class="n">the_lock</span><span class="p">:</span>
                    <span class="n">coin_updates</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">.</span><span class="n">sprite_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">center_x</span><span class="p">,</span>
                                     <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">.</span><span class="n">sprite_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">center_y</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">))]</span>
                    <span class="n">payload</span> <span class="o">=</span> <span class="p">{</span><span class="s">'updates'</span><span class="p">:</span> <span class="n">coin_updates</span><span class="p">}</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">publish_payload</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="s">'update_coins'</span><span class="p">)</span>
</code></pre></div></div>

<p>Here, we removed the check for sprite collision detection and the code to increase the score.</p>

<p>We added code to check if the sprites are currently in motion using the <em>go</em> attribute. Then player 0, 
the computer-controlled coins player, builds an array of all of the remaining coinsâ€™ center x and y positions
and then publishes that information using the <em>update_coins</em> topic string.</p>

<p>The data is gathered using a list comprehension for speed and clarity. Because both the <em>arcade</em> event-loop and
Banyan event-loop require access to the coin_list, we want to make sure that only one thread at a time
has access to the coin_list.
This ensures the data integrity of the coin_list for both threads.</p>

<h3 id="the-banyan-thread">The Banyan Thread</h3>

<h4 id="starting-the-thread">Starting The Thread</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1"># Process banyan subscribed messages
</span>    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""
        This thread continually attempts to receive
        incoming Banyan messages. If a message is received,
        incoming_message_processing is called to handle
        the message.

        """</span>
        <span class="c1"># start the banyan loop - incoming messages will be processed
</span>        <span class="c1"># by incoming_message_processing in this thread.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">receive_loop</span><span class="p">()</span>
</code></pre></div></div>

<p>When the Banyan thread begins, it starts the Banyan receive_loop. The receive_loop
internally runs forever, and therefore this thread will stay alive for the lifetime
of the program</p>

<h4 id="processing-incoming-banyan-message">Processing Incoming Banyan Message</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">def</span> <span class="nf">incoming_message_processing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topic</span><span class="p">,</span> <span class="n">payload</span><span class="p">):</span>
        <span class="s">"""
        Process the incoming Banyan messages

        :param topic: Message Topic string.

        :param payload: Message Data.
        """</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">external_message_processor</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">external_message_processor</span><span class="p">(</span><span class="n">topic</span><span class="p">,</span> <span class="n">payload</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># update the coins positions
</span>            <span class="k">if</span> <span class="n">topic</span> <span class="o">==</span> <span class="s">'update_coins'</span><span class="p">:</span>
                <span class="c1"># get the new coordinates
</span>                <span class="n">the_coordinates</span> <span class="o">=</span> <span class="n">payload</span><span class="p">[</span><span class="s">'updates'</span><span class="p">]</span>
                <span class="c1"># update the coin positions with the new coordinates
</span>                <span class="k">with</span> <span class="bp">self</span><span class="p">.</span><span class="n">the_lock</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">the_coordinates</span><span class="p">)):</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">.</span><span class="n">sprite_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">center_x</span> <span class="o">=</span> <span class="n">the_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> \
                                <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">.</span><span class="n">sprite_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">change_x</span>
                            <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">.</span><span class="n">sprite_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">center_y</span> <span class="o">=</span> <span class="n">the_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> \
                                <span class="o">+</span> <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">.</span><span class="n">sprite_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">change_y</span>

                            <span class="c1"># If we are out-of-bounds, then 'bounce'
</span>                            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">.</span><span class="n">sprite_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">left</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">.</span><span class="n">sprite_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">change_x</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

                            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">.</span><span class="n">sprite_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">right</span> <span class="o">&gt;</span> <span class="n">SCREEN_WIDTH</span><span class="p">:</span>
                                <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">.</span><span class="n">sprite_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">change_x</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

                            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">.</span><span class="n">sprite_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bottom</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">.</span><span class="n">sprite_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">change_y</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

                            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">.</span><span class="n">sprite_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">top</span> <span class="o">&gt;</span> <span class="n">SCREEN_HEIGHT</span><span class="p">:</span>
                                <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">.</span><span class="n">sprite_list</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">change_y</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="c1"># this should not happen, but if it does,
</span>                        <span class="c1"># just ignore and go along our merry way.
</span>                        <span class="k">except</span> <span class="p">(</span><span class="nb">TypeError</span><span class="p">,</span> <span class="nb">IndexError</span><span class="p">):</span>
                            <span class="k">continue</span>

                <span class="c1"># perform hit detection if enabled with the right mouse button.
</span>                <span class="k">with</span> <span class="bp">self</span><span class="p">.</span><span class="n">the_lock</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">run_collision_detection</span><span class="p">:</span>
                        <span class="n">hit_list</span> <span class="o">=</span> <span class="n">arcade</span><span class="p">.</span><span class="n">check_for_collision_with_list</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">player_sprite</span><span class="p">,</span>
                                                                        <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">)</span>
                        <span class="c1"># hit detected
</span>                        <span class="k">if</span> <span class="n">hit_list</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">coin</span> <span class="ow">in</span> <span class="n">hit_list</span><span class="p">:</span>
                                <span class="c1"># publish a remove_coin message using the coin
</span>                                <span class="c1"># index as the payload. The index is necessary
</span>                                <span class="c1"># so that we can remove coins for both players.
</span>                                <span class="n">coin_index</span> <span class="o">=</span> <span class="n">coin</span><span class="p">.</span><span class="n">my_index</span>
                                <span class="n">payload</span> <span class="o">=</span> <span class="p">{</span><span class="s">'coin'</span><span class="p">:</span> <span class="n">coin_index</span><span class="p">}</span>
                                <span class="bp">self</span><span class="p">.</span><span class="n">publish_payload</span><span class="p">(</span><span class="n">payload</span><span class="p">,</span> <span class="s">'remove_coin'</span><span class="p">)</span>
                                <span class="c1"># allow time for the message to be published cleanly
</span>                                <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(.</span><span class="mi">0001</span><span class="p">)</span>

            <span class="c1"># move player `1` on the screen
</span>            <span class="k">elif</span> <span class="n">topic</span> <span class="o">==</span> <span class="s">'p1_move'</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">player_sprite</span><span class="p">.</span><span class="n">center_x</span> <span class="o">=</span> <span class="n">payload</span><span class="p">[</span><span class="s">'p1_x'</span><span class="p">]</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">player_sprite</span><span class="p">.</span><span class="n">center_y</span> <span class="o">=</span> <span class="n">payload</span><span class="p">[</span><span class="s">'p1_y'</span><span class="p">]</span>
            <span class="c1"># now actually remove the coin identified in hit detection
</span>            <span class="c1"># by using its index.
</span>            <span class="k">elif</span> <span class="n">topic</span> <span class="o">==</span> <span class="s">'remove_coin'</span><span class="p">:</span>
                <span class="k">with</span> <span class="bp">self</span><span class="p">.</span><span class="n">the_lock</span><span class="p">:</span>
                    <span class="n">coin_index</span> <span class="o">=</span> <span class="n">payload</span><span class="p">[</span><span class="s">'coin'</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">coin</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">coin_list</span><span class="p">.</span><span class="n">sprite_list</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">coin_index</span> <span class="o">==</span> <span class="n">coin</span><span class="p">.</span><span class="n">my_index</span><span class="p">:</span>
                            <span class="n">coin</span><span class="p">.</span><span class="n">remove_from_sprite_lists</span><span class="p">()</span>
                            <span class="bp">self</span><span class="p">.</span><span class="n">score</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">topic</span> <span class="o">==</span> <span class="s">'enable_coins'</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">go</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="n">topic</span> <span class="o">==</span> <span class="s">'enable_collisions'</span><span class="p">:</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">run_collision_detection</span> <span class="o">=</span> <span class="bp">True</span>
</code></pre></div></div>
<p>The <em>incoming_message_processing</em> method is called by the <em>receive_loop</em> when an incoming
message arrives.</p>

<p>Each message is processed in accordance with its topic string.</p>

<p>The â€˜update_coinsâ€™ message updates each coinâ€™s screen position. This code 
was originally in the Coin class update method. In addition, it duplicates the original 
â€˜bounce logicâ€™ as well. Sprite collision is performed here
so that coins can be removed from the coin list, and the score increased when a collision is detected.</p>

<p>The â€˜p1_moveâ€™ message updates the collection spriteâ€™s position on the screen.</p>

<p>The enable_coins and enable_collisions messages set their respective flags to 
enable game functionality.</p>

<blockquote>
  <p>NOTE: Both player 0 and player 1 receive and process these messages. However, the generation
of these messages in the <em>Arcade</em> event-loop thread is typically generated by only one player.</p>
</blockquote>

<h1 id="concluding-comments">Concluding Comments</h1>

<p>We have seen that <em>Arcade</em> can be enhanced to become a multi-player p2p game engine with
the use of Python Banyan and the Python threading library. There were no changes made to the
<em>Arcade</em> library nor to the Python Banyan Framework.</p>

<p>Now itâ€™s up to you to try your hand at creating a multi-player p2p game!</p>
:ET